<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet type='text/xsl' href='http://xml.resource.org/authoring/rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<rfc category="info" ipr="full3978" docName="portable_contacts-1_0.xml">

  <?rfc toc="yes" ?>
  <?rfc tocdepth="3" ?>
  <?rfc symrefs="yes" ?>
  <?rfc sortrefs="yes"?>
  <?rfc strict="yes" ?>
  <?rfc iprnotified="no" ?>
  <?rfc private="Implementers' Draft" ?>

  <front>
    <title>Portable Contacts 1.0 Draft A</title>

    <author initials="J" surname="Smarr" fullname="Joseph Smarr">
      <organization>Plaxo</organization>
      <address>
        <email>joseph@plaxo.com</email>
      </address>
    </author>

    <date day="11" month="June" year="2008"/>

    <abstract>
      <t>
        The goal of Portable Contacts is to make it easier for developers to give their
        users a secure way to access the address books and friends lists they have built
        up all over the web. Specifically, it seeks to create a common access pattern and
        contact schema that any site can provide, a well-specified authentication and access rules,
        standard libraries that can work with any site, and absolutely minimal complexity,
        with the lightest possible toolchain requirements for developers.
      </t>
    </abstract>

  </front>
  <middle>

    <section title="Notation and Conventions">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref target="RFC2119" />.
        Domain name examples use <xref target="RFC2606" />.
      </t>
    </section>

    <section title="Definitions">
      <t>
        <list style="hanging">
          <t hangText="Contact:">
            A record describing information about a particular person or entity, consistenting of contact information (sometimes including name, e-mail addresses, phone numbers, and other information) and other information, as is typically found in address book and social networking applications.
          </t>
          <t hangText="Service Provider:">
            A web application that provides Contacts information
            via the Portable Contacts protocol.
          </t>
          <t hangText="Consumer:">
            A website or application that uses the Portable Contacts protocol
            to request contacts managed by the Service Provider.
          </t>
          <t hangText="Base URL:">
            The root endpoint URL specified by the Service Provider during Discovery and used to make requests. Consumers MAY append additonal path information and query string parameters to this URL as part of the request.
          </t>
        </list>
      </t>
    </section>

    <section title="Introduction">
      <t>
        This API defines a language- and platform- neutral protocol for Consumers to request address book, profile, and friends-list information from Service Providers. As a protocol, it is indeded to be easy to understand and implement, either as a Service Provider or Consumer, using any language or platform of choice. It is also intended to be implemented by both individuals and small services as well as large providers, in any case where a service contains data about who a user knows and wishes to make that information portable, under the user's control.
      </t>
      <t>
        While there are currently standards for describing contact info (such as vCard), these standards do not specify how to discover, access, and manipulate this information, and they do not capture the full range of information typically found in modern address book and social networking applications. Several large companies have also released their own custom, proprietary APIs for accessing contact info, but they are all different, which creates a burden for developers wishing to interact with several providers, and does not inform additional providers as to how they should construct a similar API. Thus Portable Contacts is an attempt to specify a complete, modern, and simple recipe for providers of all sizes to make this data available in a standard way.
      </t>
      <section title="Goals">
        <t>
          The goal of Portable Contacts is to make it easier for developers to give their users a secure way to access the address books and friends lists they have built up all over the web. Specifically, we seek to create:
          <list style="symbols">
            <t>A common access pattern and contact schema that any site can provide</t>
            <t>Well-specified authentication and access rules</t>
            <t>Standard libraries that can work with any site</t>
            <t>and absolutely minimal complexity, with the lightest possible toolchain requirements for developers.</t>
          </list>
        </t>
        <t>
          A measure of our success will be the elimination of the "password anti-pattern," by making it far easier to implement Portable Contacts than to engage in scraping, as well as a dramatic increase in the number of sites that both provide and consume who-you-know data.
        </t>
      </section>
      <section title="Approach">
        <t>
          Our design is focused around ease of adoption, which means a few things. First, our emphasis is on simplicity of design and targeted use cases. For example, version 1 is simply about access, and defers for now on the more complex issues around update and sync. Second, we're taking a modern approach to who-you-know data by unifying traditional contact info and social network data, in order to properly represent the current diversity of the social web ecosystem. Third, we're using existing standards wherever possible, including vCard, OpenSocial, XRDS-Simple, OAuth, etc. And lastly, we're designing something that should be easy for current service providers to adopt. We started by reviewing all the major existing contacts APIs and targeting the capabilities that they all share and provide. We believe this pragmatic balance is the best and quickest way to achieve our shared goal of widespread adoption.
        </t>
      </section>
    </section>
    
    <section title="Workflow Overview">
      <t>
        A Consumer wishing to access a user's data via Portable Contacts must start with an Initial Identifier for the Service Provider containing the user's data, usually provided by the user. In many cases, this may be the domain name of the Service Provider's web site, such as sample.site.org, but may be a more specific URL, such as the OpenID URL of the user, if available. Consumers then perform Discovery on the Initial Identifier to determine where the Portable Contacts endpoint for this Service Provider resides. If successful, the Consumer may then attempt to request information from that endpoint. If the endpoint contains private data, the Service Provider will return an authorization challenge, and the Consumer must then guide the user through an appropriate authorization flow to obtain the credentials necessary to access this private data. Upon successful authorization, the Consumer may request data from the Portable Contacts endpoint using these authorization credentials. Whether accessing public or private data, Consumers may request a specific subset of the user's data using standard Query Parameters. Upon a successful request, the data is returned in the response, and the Consumer may then parse the response data and use it as desired. The following sections detail each of these steps.
      </t>
    </section>

    <section title="Discovery" anchor="discovery">
      <t>
        Portable contacts API endpoint is discoverable from the domain root using XRDS-Simple (previously known as YADIS).
        The API is identified by the Service Type http://portablecontacts.net/spec/1.0 and the corresponding URI is the Base URL for the API. The Base URL MUST NOT contain any query string, as additional path information and query string variables MAY be appended by Consumers as part of forming the request (as described in detail below).
      </t>
      <t>
        An example XRDS-Simple document describing the availability and location of a Portable Contacts endpoint might look like this:
        <figure>
          <artwork><![CDATA[
<XRDS xmlns="xri://$xrds">
  <XRD xmlns:simple="http://xrds-simple.net/core/1.0" xmlns="xri://$XRD*($v*2.0)" version="2.0">
    <Type>xri://$xrds*simple</Type>
    <Service>
      <Type>http://portablecontacts.net/spec/1.0</Type>
      <URI>http://sample.site.org/path/to/api/</URI>
    </Service>
  </XRD>
</XRDS>          
          ]]></artwork>
        </figure>
      </t>
      <t>
        In addition to discovering the endpoint itself, Service Providers using OAuth to protect responses MUST also support OAuth Discovery, as described in <xref target="auth" />.
      </t>
    </section>

    <section title="Invocation">
      <t>
        All requests to the Service Provider are made as HTTP GET operations on a URL deriving from the Base URL specified in <xref target="discovery" />. Consumers MAY append additional path information and/or query string parameters to the Base URL as part of the request, as specified in <xref target="query-params" />. Additionally, authentication information MAY be sent via additional HTTP heades in the request, as specified in <xref target="auth" />. Responses are returned in the body of the HTTP response, formatted as JSON or XML, depending on what is requested. Response and error codes SHOULD be transmitted via the HTTP stauts code of the response (if possible), and SHOULD also be specified in the body of the response, as described in <xref target="response-format" /> and <xref target="error-codes" />. Since the API endpoint is dynamic (and not serving static content), Consumers MUST NOT interpret any cache headers in the response as having meaning concerning when the same URL request might return a different response upon subsequent invocation.
      </t>

      <section title="Authentication and Authorization" anchor="auth">
        <t>
          The data returned by a Portable Contacts endpoint MAY contain public data, or it MAY contain private data. If the data returned is public, no authentication or authorization is required. In most cases however, the data returned is not public, and Service Providers SHOULD ensure that the user has given prior consent, either explicitly or implicitly, for their information to be released by this API. Typically this is done by Consumers obtaining either Direct Authorization (with raw credentials, for example the user's username and password) or Delegated Authorization (with an access token obtained out-of-band by the user, and given to the Consumer to present as part of the request). Portable Contacts specifies standard mechanisms for both types of authorization, so that Consumers may be able to obtain private data on a user's behalf from Service Providers in an automated and consistent fashion. Regardless of the Authorization method used, the context of the request (i.e. the user for whom data is being requested) MUST be inferred by Service Providers from the Base URL and the authorization credentials provided. If public data is being accessed (and no authorization is provided), the Base URL MUST contain enough information for Service Providers to know which data to return, but if private data is being accessed (and authorization is provided), the same Base URL MAY return information for different users depending on the authorization credentials provided.
        </t>
        <section title="Delegated Authorization">
          <t>
            Service Providers wishing to provide Delegated Authorization MUST support <xref target="OAuth Core 1.0" /> as an OAuth Service Provider, and MAY also support additional Delegated Authorization mechanisms, if they choose. Service Providers supporting OAuth MUST also support OAuth Discovery (TODO: xref) to facilitate automatic discovery of authorization endpoints for Consumers. Service Providers SHOULD provide a mechanism for Consumers to automatically obtain a Consumer Key and Consumer Secret, but MAY require this to be done out-of-band.
          </t>
        </section>
        <section title="Direct Authorization">
          <t>
            Service Providers wishing to provide Direct Authorization MUST support HTTP-Basic (TODO: xref) authentication, and MAY also support additional Direct Authorization mechanisms, if they choose. In addition to being a well-established mechanism for Direct Authorization, HTTP Basic has the added benefit of being understood by most Web Browsers, and can prompt users to enter their credentials as part of accessing a resource protected in this manner. There are also convenient ways of providing and parsing HTTP Basic credentials in popular tools and libraries like curl and PHP.
          </t>
        </section>
          <section title="Available Authorization Methods">
          <t>
            Service Providers that provide access to private data MAY choose not to support either Direct Authorization or Delegated Authorization, depending on their security requirements, but they MUST support either OAuth or HTTP Basic auth if they require any Authorization. When accessing a Portable Contacts endpoint, if sufficient authorization credentials are not provided, the Service Provider SHOULD return a 401 Unauthorized response, and SHOULD provide the available Authorization mechanisms available by including WWW-Authenticate headers in the response for each type of Authorization method supported. Consumers will then be able to recognize that the API is a protected resource and initiate the proper Authorization process needed to obtain the appropriate credentials. An example set of WWW-Authenticate headers returned by a Service Provider that supports both OAuth and HTTP Basic might look like this:
            <figure>
              <artwork>
WWW-Authenticate: OAuth realm="sample.site.org"
WWW-Authenticate: Basic realm="sample.site.org"
              </artwork>
            </figure>
          </t>
          <t>
            If Service Providers wish to make some response data publicly available and also provide additional info given the proper authorization credentials, they SHOULD provide a 200 OK response to requests without authorization with a WWW-Authenticate header in the response indicating that additional info is available via the specified authorization mechanisms.
          </t>
        </section>
      </section>
      
      <section title="Additional Path Information">
        <t>
          A request using the Base URL alone MUST yield a result, providing that adequate authorization credentials are provided. In addition, Consumers MAY append additional path information to the Base URL to request more specific information. Service Providers MUST recognize the following additional path information when appended to the Base URL, and MUST return the corresponding data:
          <list style="symbols">
            <t>
              <spanx style="verb">/@me/@all</spanx> -- Return all contact info (equivalent to providing no additional path info)
            </t>
            <t>
              <spanx style="verb">/@me/@all/{ID}</spanx> -- Only return contact info for the contact whose <spanx style="verb">id</spanx> value is equal to the provided {ID}, if such a contact exists. In this case, the response format is the same as when requesting all contacts, but any contacts not matching the requested ID MUST be filtered out of the result list by the Service Provider
            </t>
            <t>
              <spanx style="verb">/@me/@self</spanx> -- Return contact info for the owner of this information, i.e. the user on whose behalf this request is being made. In this case, the response format is the same as when requesting all contacts, but any contacts not matching the requested ID MUST be filtered out of the result list by the Service Provider.
            </t>
          </list>
        </t>
      </section>

      <section title="Query Parameters" anchor="query-params">
        <t>
          Portable Contacts defines a standard set of operations that can be used
          to filter, sort, and paginate response results. The operations are specified
          by adding query parameter to the Base URL, either in the query string or as
          HTTP POST data.
        </t>

        <section title="Filtering">
          <t>
            Filtering is used to limit the request results to Contacts that match a given
            criterion. Content filtering is accomplished by combining three request parameters:

            <list style="hanging">
              <t hangText="filterBy:">
                Specifies the field name to filter by. If the field is not a direct child of the
                <spanx style="verb">contact</spanx> element, the full path MUST be specified using
                the '/' character as seperator. For example, to filter by gender the paramter value
                is 'gender' and to filter by first name, the parameter value is 'name/givenName'.
              </t>
              <t hangText="filterOp:">
                Defines the comparison method used to evaluate the field value with the value of
                the filter criterion. Allowed values are:
                <list style="symbols">
                  <t>
                    <spanx style="verb">equals</spanx>: the two values must be identical strings.
                  </t>
                  <t>
                    <spanx style="verb">contains</spanx>: the entire <spanx style="verb">filterValue</spanx>
                    must be a substring of the Contact field value.
                  </t>
                  <t>
                    <spanx style="verb">startswith</spanx>: the entire <spanx style="verb">filterValue</spanx>
                    must be a substring of the Contact field value, starting at the beginning of the field value. This
                    criterion is satisfied if the two strings are equal.
                  </t>
                  <t>
                    <spanx style="verb">present</spanx>: a Contact matches the criterion if the field specified by
                    <spanx style="verb">filterBy</spanx> has a non-empty value, or if it contains a non empty node
                    for complex fields.
                  </t>
                </list>
              </t>
              <t hangText="filterValue:">
                Specified the value to filter by, using the comparison method defined by <spanx style="verb">filterOp</spanx>.
              </t>
            </list>
          </t>
          <t>
            In addition, requests can filter content based on their update timestamp:
            
            <list style="hanging">
              <t hangText="modifiedSince:">
                Returns only contacts that have been modified on or after the given time, specified
                as an xs:dateTime. The filter is based on the value of the <spanx style="verb">modified</spanx> field,
                and can be used independently of other filters or combined. It enables a basic syndication pattern when
                accessing the same data over time. The first API call returns all data, which can be stored locally.
                Subsequent API calls can specify <spanx style="verb">modifiedSince</spanx> with the time of the last
                API call, so that only contacts that have been added or modified since the last API call will be returned.
              </t>
            </list>
          </t>
          <t>
            Here are a few illustrative examples of filtering matches with <spanx style="verb">filterBy</spanx>,
            <spanx style="verb">filterOp</spanx>, and <spanx style="verb">filterValue</spanx>.
            In each case, assume the following two contacts would be returned if no filtering parameters were provided:
            
          <figure>
            <artwork>
      {
        "id": "1",
        "name": "Chris Messina",
        "url": [
          { "value": "http://factoryjoe.com/blog", "type": "blog" }
        ]
      },
      {
        "id": "2",
        "name": "Joseph Smarr",
        "email": [
          { "value": "joseph@plaxo.com", "type": "work", "primary": "true" },
          { "value": "jsmarr@gmail.com", "type": "home" }
        ],
      }
            </artwork>
          </figure>

            Given the parameters <spanx style="verb">filterBy=name&amp;filterOp=startswith&amp;filterValue=Chr</spanx>,
            only the first contact (with id=1) would match and be returned. However, with
            parameters <spanx style="verb">filterBy=name&amp;filterOp=present</spanx>, both contacts would be returned.
            Given the parameters <spanx style="verb">filterBy=email&amp;filterOp=contains&amp;filterValue=plaxo.com</spanx>,
            only the second contact (with id=2) would match, as would it be the only contact
            to match given the parameters <spanx style="verb">filterBy=email&amp;filterOp=present</spanx>.
          </t>

        </section>

        <section title="Sorting">
          <t>
            Sorting allows requests to specify the order in which contacts are returned.
            
            <list style="hanging">
              <t hangText="sortBy">
                Specifies the field name whose value SHALL be used to order the returned Contacts.
                The sort order is determine by the <spanx style="verb">sortOrder</spanx> parameter.
                If <spanx style="verb">sortBy</spanx> is a Singular Field, contacts are sorted according
                to that field’s value; if it’s a Plural Field, contacts are sorted by the Value
                (or Major Value, if it’s a Plural Bundle Field) of the field marked with “primary”: “true”,
                if any, or else the first value in the list, if any, or else they are sorted last if the
                given contact has no data for the given field.
              </t>
              <t hangText="sortOrder">
                The order in which the <spanx style="verb">sortBy</spanx> parameter is applied. Allowed values
                are <spanx style="verb">ascending</spanx> and <spanx style="verb">descending</spanx>. If none specified
                the sort order defaults to <spanx style="verb">ascending</spanx>. Sort order is expected to be
                Unicode alphabetic sort order, with no specific locale implied.
              </t>
            </list>
          </t>
        </section>

        <section title="Pagination">
          <t>
            The pagination parameters can be used together to “page through” a large number of results:
            
            <list style="hanging">
              <t hangText="startIndex:">
                Specifies the offset of the first result to be returned with respect to the list
                of contacts that would be returned if no offset were provided. For instance, if
                in a given request 10 contacts would normally be provided, if <spanx style="verb">startIndex</spanx>
                is 7 and no <spanx style="verb">limit</spanx> is specified, then only the last 3 contacts in that
                list would be returned (contacts are zero-indexed). If <spanx style="verb">startIndex</spanx> is
                greater than or equal to the total number of results that would be returned, no contacts are returned.
                Value MUST be a non-negative integer and defaults to 0 if none specified.
              </t>
              <t hangText="limit:">
                If non-zero, specifies the maximum number of contacts the service provider will return.
                Value MUST be a non-negative integer and defaults to 0 if none is specified. Specifying
                a <spanx style="verb">limit</spanx> of 0 means that no limit should be placed
                on the number of contacts returned. Otherwise, at most <spanx style="verb">limit</spanx>
                contacts will be returned, starting at <spanx style="verb">startIndex</spanx> and counting
                up from there.
              </t>
            </list>
            
            For instance, on an initial query, specifying <spanx style="verb">startIndex=0&amp;limit=10</spanx>
            will return the first only the first 10 results. The total number of possible results is indicated
            by the totalCount field of results, so the client knows how many “pages” of results exist.
            A subsequent query of <spanx style="verb">startIndex=10&amp;limit=10</spanx> will return the next
            10 results, and so on.
          </t>
        </section>

        <section title="Presentation">
          <t>
            Presentation controls the format, makeup, and delivery mechanism for delivering the requested
            result set:
            
            <list style="hanging">
              <t hangText="format:">
                Specifies the format in which the response data is returned. Supports: JSON (http://json.org)
                or XML (http://www.w3.org/XML/) and defaults to JSON is none specified.
                The data structure returned is equivalent in both formats,
                with the only difference is in the encoding of the data. Singlular Fields are encoded as string
                key/value pairs in JSON and tags with text content in XML, e.g. “field”: “value” and
                &lt;field&gt;value&lt;/field&gt; respectively. Plural Fields and Plural Bundles are encoded as
                arrays in JSON and repeated tags in XML, e.g. “field”: [ “value1”, “value2” ] and
                &lt;field&gt;value1&lt;/field&gt;&lt;field&lt;value2&lt;/field&gt; respectively.
                Nodes with multiple sub-nodes are represented as objects in JSON and tags with
                sub-tags in XML, e.g. “field”: { “subfield1”: “value1”, “subfield2”: “value2” }
                and &lt;field&gt;&lt;subfield1&gt;&lt;value1&gt;&lt;/subfield1&gt;&lt;subfield2&gt;value2&lt;/subfield2&gt;&lt;/field&gt;
                respectively.
              </t>
              <t hangText="fields:">
                If non-empty, each contact returned SHALL contain only the fields explicitly requested.
                Service Provider MAY return a subset of the requested fields if they are not supported.
                This field is used for efficiency when the client only wishes to access a subset of the
                fields normally returned in results. Value is a comma seperated list of top level field names
                and defaults to an emply list which means all fields.
              </t>
              <t hangText="callback:">
                Only applies if format=json, if so, the output is wrapped in a call to the given callback
                function, for use with AJAX JSON-P callback invocation. For instance, if the result would
                normally be { “field”: “value” } and callback=myFunc, the output would be myFunc({“field”: “value”});
                See http://developer.yahoo.com/common/json.html#callbackparam for more information. Value
                is a JavaScript callback function name. Callback function names may only use upper and
                lowercase alphabetic characters (A-Z, a-z), numbers (0-9), the period (.), the underscore (_),
                and brackets ([ and ]). Brackets must be URL-encoded.
              </t>
            </list>
          </t>
        </section>

      </section>

      <section title="Response Format" anchor="response-format">
        <t>
        </t>
      </section>

      <section title="Error Codes" anchor="error-codes">
        <t>
          The Service Provider MUST return a response code with every response.
          Response codes are numeric and based on existing HTTP response codes,
          as defined below. In addition to the response code, Service Providers
          SHOULD also provide a human-readable reason that explains the reason
          for the response code. This message SHOULD be intelligible to
          developers, but MAY be unsuitable for display to end-users.
          Clients SHOULD provide their own appropriate error message to users
          when encountering an error response.
        </t>
        <t>
          Service Providers SHOULD send their response code and message via the
          HTTP response code. Since it is recognized that developers do not always
          have an easy ability to manipulate HTTP headers, and since headers do not
          show up in the response body (e.g. when viewing results in a web browser),
          the response data also contains the code and reason fields inside the
          response where the response code and reason MUST be specified, unless the
          error is such that the Service Provider is unable to return any response
          data. If the Service Provider returns an HTTP status code other than 200,
          Consumers MUST treat it as the definitive response code, even if the
          response.code in the body differs (which it shouldn’t). However, if the
          HTTP response code is 200, Consumers MUST defer to the response.code in the
          body as the definitive response code.
        </t>
        <t>
          Service Providers SHOULD conform the following response codes to indicate
          the following situations. Service Providers MAY return additional codes to
          indicate additional information, but are encouraged to use these codes and
          augment them inside the reason rather than with a separate code.
        </t>
        <t>
          <list style="hanging">
            <t hangText="200:">
              OK (response returned successfully)
            </t>
            <t hangText="400:">
              Bad Request (request was malformed or illegal and cannot be completed)
            </t>
            <t hangText="401:">
              Unauthorized (authentication headers / parameters were invalid or missing)
            </t>
            <t hangText="404:">
              Not Found (the request points to an object that does not exist, e.g. to an
              unknown contact uid; note that Service Providers MUST return a 200 with an
              empty array of contacts if the request has filtering parameters that are
              valid but have no matches)
            </t>
            <t hangText="500:">
              Internal Server Error (un unexpected error occurred during processing)
            </t>
            <t hangText="503:">
              Service Unavailable (service is temporarily unavailable; this may be
              because the Consumer has exceeded their rate-limit of requests)
            </t>
          </list>
        </t>
      </section>

    </section>

    <section title="Contact Schema">
      <t>
        The Contact schema defines the containers and attributes used to deliver
        an individual Contact or a list of Contacts as requested by the Consumer.
      </t>

      <section title="Structure">
        <t>
          Contact information is formatted using labeled attributes with either
          structured or unstructured string data. Each attributes has a defined
          occurrence count and use one of the following types:

          <list style="hanging">
            <t hangText="Simple:">
              A single string attribute which MAY specify a REQUIRED data format or allow
              any string.
            </t>
            <t hangText="Enumeration:">
              A single string attribute with a defined set of allowed values. Service Providers
              MAY extend the schema to include additional enumeration values, but SHOULD prefix
              them with a unique namespace as defined in <xref target="namespaces" />.
            </t>
            <t hangText="Boolean">
              An attribute with one of two allowed values: <spanx style="verb">true</spanx> and
              <spanx style="verb">false</spanx>. Values are case-sensitive.
            </t>
            <t hangText="Complex:">
              A multi-value attribute containing any combination of other attributes. Complex
              attributes are defined by listing the child attributes and their types.
            </t>
          </list>
        </t>
      </section>

      <section title="Namespaces" anchor="namespaces">
        <t>
        </t>
      </section>

      <section title="contact Element">
        <t>
          <list style="hanging">
            <t hangText="id:">
              1 per <spanx style="verb">contact</spanx> element with type xs:string.
              Unique identifier for the Contact.
            </t>
            <t hangText="published:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:dateTime.
            </t>
            <t hangText="updated:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:dateTime.
            </t>
            <t hangText="name:">
              1 per <spanx style="verb">contact</spanx> element with type xs:string.
              Full name or the common display name.
            </t>
            <t hangText="preferredUsername:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:string.
            </t>
            <t hangText="familyName:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:string.
            </t>
            <t hangText="givenName:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:string.
            </t>
            <t hangText="middleName:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:string.
            </t>
            <t hangText="honorificPrefix:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:string.
            </t>
            <t hangText="honorificSuffix:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:string.
            </t>
            <t hangText="bday:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:date. The
              year value MAY be set to <spanx style="verb">0000</spanx> when the age of the
              Contact is private or the year is not available.
            </t>
            <t hangText="anniversary:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:date. The
              year value MAY be set to <spanx style="verb">0000</spanx> when the year is not available.
            </t>
            <t hangText="gender:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type enumeration.
              Allowed values: <spanx style="verb">male</spanx>, <spanx style="verb">female</spanx>,
              and <spanx style="verb">undisclosed</spanx>.
            </t>
            <t hangText="note:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:string. Text notes and comments with
              multiple lines seperated by a line feed character (ASCII 13).
            </t>
            <t hangText="connected:">
              0 or 1 <spanx style="verb">contact</spanx> element with type xs:boolean. Indicates if a two-way relationship
              is established with the Contact.
            </t>
            <t hangText="email:">
              0 or more per <spanx style="verb">contact</spanx> element with REQUIRED child elements:

              <list style="hanging">
                <t hangText="type:">Enumeration: work, home, other.</t>
                <t hangText="value:">Canonical email address (put RFC here).</t>
                <t hangText="primary:">Boolean.</t>
              </list>
            </t>
            <t hangText="url:">
              0 or more per <spanx style="verb">contact</spanx> element with REQUIRED child elements:

              <list style="hanging">
                <t hangText="type:">Enumeration: work, home, other, blog, profile.</t>
                <t hangText="value:">Absolute URI with any scheme.</t>
                <t hangText="primary:">Boolean.</t>
              </list>
            </t>
            <t hangText="im:">
              0 or more per <spanx style="verb">contact</spanx> element with REQUIRED child elements:

              <list style="hanging">
                <t hangText="type:">Enumeration: aim, gtalk, icq, xmpp, msn, skype, qq, yahoo</t>
                <t hangText="value:">Screen name</t>
                <t hangText="primary:">Boolean.</t>
              </list>
            </t>
            <t hangText="phoneNumber:">
              0 or more per <spanx style="verb">contact</spanx> element with REQUIRED child elements:

              <list style="hanging">
                <t hangText="type:">Enumeration: work, home, other, mobile, fax, pager.</t>
                <t hangText="value:">String.</t>
                <t hangText="primary:">Boolean.</t>
              </list>
            </t>
            <t hangText="photo:">
              0 or more per <spanx style="verb">contact</spanx> element with REQUIRED child elements:

              <list style="hanging">
                <t hangText="type:">Enumeration: work, home, other.</t>
                <t hangText="value:">Absolute URI of the image itself (not containing pages).</t>
                <t hangText="primary:">Boolean.</t>
              </list>
            </t>
            <t hangText="tag:">
              0 or more per <spanx style="verb">contact</spanx> element with type xs:string.
              Holds a single user-defined tag.
            </t>
            <t hangText="relationship:">
              0 or more per <spanx style="verb">contact</spanx> element with type xs:string. TBD.
            </t>
            <t hangText="address:">
              0 or more per <spanx style="verb">contact</spanx> element as defined in <xref target="address_element" />.
            </t>
            <t hangText="job:">
              0 or more per <spanx style="verb">contact</spanx> element as defined in <xref target="job_element" />.
            </t>
            <t hangText="account:">
              0 or more per <spanx style="verb">contact</spanx> element as defined in <xref target="account_element" />.
            </t>
            <t hangText="utcOffset:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:dateTime.
            </t>
          </list>
        </t>
      </section>

      <section title="address Element" anchor="address_element">
        <t>
          <list style="hanging">
            <t hangText="streetAddress:">
              0 or more per <spanx style="verb">address</spanx> element with type xs:string.
            </t>
            <t hangText="locality:">
              0 or 1 per <spanx style="verb">address</spanx> element with type xs:string.
            </t>
            <t hangText="region:">
              0 or 1 per <spanx style="verb">address</spanx> element with type xs:string.
            </t>
            <t hangText="postalCode:">
              0 or 1 per <spanx style="verb">address</spanx> element with type xs:string.
            </t>
            <t hangText="country:">
              1 per <spanx style="verb">address</spanx> element with type xs:string.
            </t>
            <t hangText="formatted:">
              0 or more per <spanx style="verb">address</spanx> element with type xs:string.
            </t>
          </list>
        </t>
      </section>

      <section title="job Element" anchor="job_element">
        <t>
          <list style="hanging">
            <t hangText="name:">
              1 per <spanx style="verb">job</spanx> element with type xs:string.
            </t>
            <t hangText="department:">
              0 or 1 per <spanx style="verb">job</spanx> element with type xs:string.
            </t>
            <t hangText="title:">
              0 or 1 per <spanx style="verb">job</spanx> element with type xs:string.
            </t>
            <t hangText="startDate:">
              0 or 1 per <spanx style="verb">job</spanx> element with type xs:date.
            </t>
            <t hangText="endDate:">
              0 or 1 per <spanx style="verb">job</spanx> element with type xs:date.
            </t>
            <t hangText="location:">
              0 or 1 per <spanx style="verb">job</spanx> element with type xs:string.
            </t>
            <t hangText="description:">
              0 or 1 per <spanx style="verb">job</spanx> element with type xs:string.
            </t>
          </list>
        </t>
      </section>

      <section title="account Element" anchor="account_element">
        <t>
          <list style="hanging">
            <t hangText="domain:">
              1 per <spanx style="verb">account</spanx> element with type xs:string.
            </t>
            <t hangText="localId:">
              1 per <spanx style="verb">account</spanx> element with type xs:string.
            </t>
          </list>
        </t>
      </section>

    </section>

    <section title="Security and Privacy Considerations">
      <t>
      </t>
    </section>

    <appendix title="Appendix A - Example">
      <t>
      </t>
    </appendix>

  </middle>

  <back>

    <references title="References">

      <reference anchor="OAuth Core 1.0">
        <front>
          <title>OAuth Core 1.0</title>
          <author initials="" surname="OAuth Core Workgroup" fullname="OAuth Core Workgroup">
            <organization />
          </author>
        </front>
        <format type="HTML" target="http://oauth.net/core/1.0" />
      </reference>

      <reference anchor="RFC2606">
        <front>
          <title>Reserved Top Level DNS Names</title>
          <author initials="D.E" surname="Eastlake" fullname="D. Eastlake">
            <organization></organization>
          </author>
          <author initials="A.P" surname="Panitz" fullname="A. Panitz">
            <organization></organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="2606" />
      </reference>

      <reference anchor="RFC2119">
        <front>
          <title>Key words for use in RFCs to Indicate Requirement Levels</title>
          <author initials="B.S" surname="Bradner" fullname="Scott Bradner">
            <organization>Alis Technologies</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="2119" />
      </reference>

    </references>
  </back>

</rfc>
