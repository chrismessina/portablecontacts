<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet type='text/xsl' href='http://xml.resource.org/authoring/rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<rfc category="info" ipr="full3978" docName="portable_contacts-1_0.xml">

  <?rfc toc="yes" ?>
  <?rfc tocdepth="3" ?>
  <?rfc symrefs="yes" ?>
  <?rfc sortrefs="yes"?>
  <?rfc strict="yes" ?>
  <?rfc iprnotified="no" ?>
  <?rfc private="Implementers' Draft" ?>

  <front>
    <title>Portable Contacts 1.0 Draft A</title>

    <author initials="J" surname="Smarr" fullname="Joseph Smarr">
      <organization>Plaxo</organization>
      <address>
        <email>joseph@plaxo.com</email>
      </address>
    </author>

    <date day="11" month="June" year="2008"/>

    <abstract>
      <t>
        The goal of Portable Contacts is to make it easier for developers to give their users a secure way to access the address books and friends lists they have built up all over the web. Specifically, it seeks to create a common access pattern and contact schema that any site can provide, a well-specified authentication and access rules, standard libraries that can work with any site, and absolutely minimal complexity, with the lightest possible toolchain requirements for developers.
      </t>
      <t>
        By far the easiest way to start understanding this spec is to jump to the example in the Appendix. The format and meaning of the response should be readily apparent, and the majority of this document is merely an attempt to formalize the details of what should be relatively clear from this example.
      </t>
    </abstract>

  </front>
  <middle>

    <section title="Notation and Conventions">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119" />. Domain name examples use <xref target="RFC2606" />.
      </t>
    </section>

    <section title="Definitions">
      <t>
        <list style="hanging">
          <t hangText="Contact:">
            A record describing information about a particular person or entity, consistenting of contact information (sometimes including name, e-mail addresses, phone numbers, and other information) and other information, as is typically found in address book and social networking applications.
          </t>
          <t hangText="Service Provider:">
            A web application that provides Contacts information via the Portable Contacts protocol.
          </t>
          <t hangText="Consumer:">
            A website or application that uses the Portable Contacts protocol to request contacts managed by the Service Provider.
          </t>
          <t hangText="Base URL:">
            The root endpoint URL specified by the Service Provider during Discovery and used to make requests. Consumers MAY append additonal path information and query string parameters to this URL as part of the request.
          </t>
          <t hangText="Singular Field:">
            A contact field that can only apopear at most once per contact, e.g. <spanx style="verb">name</spanx> or <spanx style="verb">gender</spanx>.
          </t>
          <t hangText="Plural Field:">
            A contact field that can appear multiple times per contact, e.g. <spanx style="verb">email</spanx> or <spanx style="verb">category</spanx>.
          </t>
          <t hangText="Canonical Value:">
            Specified string values for string-valued contact fields that represent common values in a canonical form, e.g. "male" and "female" for <spanx style="verb">gender</spanx>. Service Providers SHOULD confirm to Canonical Values if appropriate, but MAY deviate if they need to represent additional values.
          </t>
        </list>
      </t>
    </section>

    <section title="Introduction">
      <t>
        This API defines a language- and platform- neutral protocol for Consumers to request address book, profile, and friends-list information from Service Providers. As a protocol, it is indeded to be easy to understand and implement, either as a Service Provider or Consumer, using any language or platform of choice. It is also intended to be implemented by both individuals and small services as well as large providers, in any case where a service contains data about who a user knows and wishes to make that information portable, under the user's control.
      </t>
      <t>
        While there are currently standards for describing contact info (such as vCard), these standards do not specify how to discover, access, and manipulate this information, and they do not capture the full range of information typically found in modern address book and social networking applications. Several large companies have also released their own custom, proprietary APIs for accessing contact info, but they are all different, which creates a burden for developers wishing to interact with several providers, and does not inform additional providers as to how they should construct a similar API. Thus Portable Contacts is an attempt to specify a complete, modern, and simple recipe for providers of all sizes to make this data available in a standard way.
      </t>
      <section title="Goals">
        <t>
          The goal of Portable Contacts is to make it easier for developers to give their users a secure way to access the address books and friends lists they have built up all over the web. Specifically, we seek to create:
          <list style="symbols">
            <t>A common access pattern and contact schema that any site can provide</t>
            <t>Well-specified authentication and access rules</t>
            <t>Standard libraries that can work with any site</t>
            <t>and absolutely minimal complexity, with the lightest possible toolchain requirements for developers.</t>
          </list>
        </t>
        <t>
          A measure of our success will be the elimination of the "password anti-pattern," by making it far easier to implement Portable Contacts than to engage in scraping, as well as a dramatic increase in the number of sites that both provide and consume who-you-know data.
        </t>
      </section>
      <section title="Approach">
        <t>
          Our design is focused around ease of adoption, which means a few things. First, our emphasis is on simplicity of design and targeted use cases. For example, version 1 is simply about access, and defers for now on the more complex issues around update and sync. Second, we're taking a modern approach to who-you-know data by unifying traditional contact info and social network data, in order to properly represent the current diversity of the social web ecosystem. Third, we're using existing standards wherever possible, including vCard, OpenSocial, XRDS-Simple, OAuth, etc. And lastly, we're designing something that should be easy for current service providers to adopt. We started by reviewing all the major existing contacts APIs and targeting the capabilities that they all share and provide. We believe this pragmatic balance is the best and quickest way to achieve our shared goal of widespread adoption.
        </t>
      </section>
    </section>
    
    <section title="Workflow Overview">
      <t>
        A Consumer wishing to access a user's data via Portable Contacts must start with an Initial Identifier for the Service Provider containing the user's data, usually provided by the user. In many cases, this may be the domain name of the Service Provider's web site, such as sample.site.org, but may be a more specific URL, such as the OpenID URL of the user, if available. Consumers then perform Discovery on the Initial Identifier to determine where the Portable Contacts endpoint for this Service Provider resides. If successful, the Consumer may then attempt to request information from that endpoint. If the endpoint contains private data, the Service Provider will return an authorization challenge, and the Consumer must then guide the user through an appropriate authorization flow to obtain the credentials necessary to access this private data. Upon successful authorization, the Consumer may request data from the Portable Contacts endpoint using these authorization credentials. Whether accessing public or private data, Consumers may request a specific subset of the user's data using standard Query Parameters. Upon a successful request, the data is returned in the response, and the Consumer may then parse the response data and use it as desired. The following sections detail each of these steps.
      </t>
    </section>

    <section title="Discovery" anchor="discovery">
      <t>
        Portable contacts API endpoint is discoverable from the domain root using <xref target="XRDS-Simple" /> (previously known as YADIS). The API is identified by the Service Type http://portablecontacts.net/spec/1.0 and the corresponding URI is the Base URL for the API. The Base URL MUST NOT contain any query string, as additional path information and query string variables MAY be appended by Consumers as part of forming the request (as described in detail below).
      </t>
      <t>
        An example XRDS-Simple document describing the availability and location of a Portable Contacts endpoint might look like this:
        <figure>
          <artwork><![CDATA[
<XRDS xmlns="xri://$xrds">
  <XRD xmlns:simple="http://xrds-simple.net/core/1.0" xmlns="xri://$XRD*($v*2.0)" version="2.0">
    <Type>xri://$xrds*simple</Type>
    <Service>
      <Type>http://portablecontacts.net/spec/1.0</Type>
      <URI>http://sample.site.org/path/to/api/</URI>
    </Service>
  </XRD>
</XRDS>          
          ]]></artwork>
        </figure>
      </t>
      <t>
        In addition to discovering the endpoint itself, Service Providers using OAuth to protect responses MUST also support OAuth Discovery, as described in <xref target="auth" />.
      </t>
    </section>

    <section title="Invocation">
      <t>
        All requests to the Service Provider are made as HTTP GET operations on a URL deriving from the Base URL specified in <xref target="discovery" />. Consumers MAY append additional path information and/or query string parameters to the Base URL as part of the request, as specified in <xref target="query-params" />. Additionally, authentication information MAY be sent via additional HTTP heades in the request, as specified in <xref target="auth" />. Responses are returned in the body of the HTTP response, formatted as JSON or XML, depending on what is requested. Response and error codes SHOULD be transmitted via the HTTP stauts code of the response (if possible), and SHOULD also be specified in the body of the response, as described in <xref target="response-format" /> and <xref target="error-codes" />. Since the API endpoint is dynamic (and not serving static content), Consumers MUST NOT interpret any cache headers in the response as having meaning concerning when the same URL request might return a different response upon subsequent invocation.
      </t>

      <section title="Authentication and Authorization" anchor="auth">
        <t>
          The data returned by a Portable Contacts endpoint MAY contain public data, or it MAY contain private data. If the data returned is public, no authentication or authorization is required. In most cases however, the data returned is not public, and Service Providers SHOULD ensure that the user has given prior consent, either explicitly or implicitly, for their information to be released by this API. Typically this is done by Consumers obtaining either Direct Authorization (with raw credentials, for example the user's username and password) or Delegated Authorization (with an access token obtained out-of-band by the user, and given to the Consumer to present as part of the request). Portable Contacts specifies standard mechanisms for both types of authorization, so that Consumers may be able to obtain private data on a user's behalf from Service Providers in an automated and consistent fashion. Regardless of the Authorization method used, the context of the request (i.e. the user for whom data is being requested) MUST be inferred by Service Providers from the Base URL and the authorization credentials provided. If public data is being accessed (and no authorization is provided), the Base URL MUST contain enough information for Service Providers to know which data to return, but if private data is being accessed (and authorization is provided), the same Base URL MAY return information for different users depending on the authorization credentials provided.
        </t>
        <section title="Delegated Authorization">
          <t>
            Service Providers wishing to provide Delegated Authorization MUST support <xref target="OAuth Core 1.0" /> as an OAuth Service Provider, and MAY also support additional Delegated Authorization mechanisms, if they choose. Service Providers supporting OAuth MUST also support <xref target="OAuth Discovery" /> to facilitate automatic discovery of authorization endpoints for Consumers. Service Providers SHOULD provide a mechanism for Consumers to automatically obtain a Consumer Key and Consumer Secret, but MAY require this to be done out-of-band.
          </t>
        </section>
        <section title="Direct Authorization">
          <t>
            Service Providers wishing to provide Direct Authorization MUST support HTTP Basic Access Authentication <xref target="RFC2617" />, and MAY also support additional Direct Authorization mechanisms, if they choose. In addition to being a well-established mechanism for Direct Authorization, HTTP Basic has the added benefit of being understood by most Web Browsers, and can prompt users to enter their credentials as part of accessing a resource protected in this manner. There are also convenient ways of providing and parsing HTTP Basic credentials in popular tools and libraries like curl and PHP.
          </t>
        </section>
          <section title="Available Authorization Methods">
          <t>
            Service Providers that provide access to private data MAY choose not to support either Direct Authorization or Delegated Authorization, depending on their security requirements, but they MUST support either OAuth or HTTP Basic auth if they require any Authorization. When accessing a Portable Contacts endpoint, if sufficient authorization credentials are not provided, the Service Provider SHOULD return a 401 Unauthorized response, and SHOULD provide the available Authorization mechanisms available by including WWW-Authenticate headers in the response for each type of Authorization method supported. Consumers will then be able to recognize that the API is a protected resource and initiate the proper Authorization process needed to obtain the appropriate credentials. An example set of WWW-Authenticate headers returned by a Service Provider that supports both OAuth and HTTP Basic might look like this:
            <figure>
              <artwork>
WWW-Authenticate: OAuth realm="sample.site.org"
WWW-Authenticate: Basic realm="sample.site.org"
              </artwork>
            </figure>
          </t>
          <t>
            If Service Providers wish to make some response data publicly available and also provide additional info given the proper authorization credentials, they SHOULD provide a 200 OK response to requests without authorization with a WWW-Authenticate header in the response indicating that additional info is available via the specified authorization mechanisms.
          </t>
        </section>
      </section>
      
      <section title="Additional Path Information">
        <t>
          A request using the Base URL alone MUST yield a result, providing that adequate authorization credentials are provided. In addition, Consumers MAY append additional path information to the Base URL to request more specific information. Service Providers MUST recognize the following additional path information when appended to the Base URL, and MUST return the corresponding data:
          <list style="symbols">
            <t>
              <spanx style="verb">/@me/@all</spanx> -- Return all contact info (equivalent to providing no additional path info)
            </t>
            <t>
              <spanx style="verb">/@me/@all/{ID}</spanx> -- Only return contact info for the contact whose <spanx style="verb">id</spanx> value is equal to the provided {ID}, if such a contact exists. In this case, the response format is the same as when requesting all contacts, but any contacts not matching the requested ID MUST be filtered out of the result list by the Service Provider
            </t>
            <t>
              <spanx style="verb">/@me/@self</spanx> -- Return contact info for the owner of this information, i.e. the user on whose behalf this request is being made. In this case, the response format is the same as when requesting all contacts, but any contacts not matching the requested ID MUST be filtered out of the result list by the Service Provider.
            </t>
          </list>
        </t>
      </section>

      <section title="Query Parameters" anchor="query-params">
        <t>
          Portable Contacts defines a standard set of operations that can be used to filter, sort, and paginate response results. The operations are specified by adding query parameter to the Base URL, either in the query string or as HTTP POST data.
        </t>

        <section title="Filtering">
          <t>
            Filtering is used to limit the request results to Contacts that match a given criterion. Content filtering is accomplished by combining three request parameters:

            <list style="hanging">
              <t hangText="filterBy:">
                Specifies the field name to filter by. If the field is not a direct child of the
                <spanx style="verb">entry</spanx> element, the full path MUST be specified using the '.' character as seperator. For example, to filter by gender the paramter value is 'gender' and to filter by first name, the parameter value is 'name.givenName'. TODO(js): should we even allow filtering by non-top-level fields?
              </t>
              <t hangText="filterOp:">
                Defines the comparison method used to evaluate the field value with the value of the filter criterion. Allowed values are:
                <list style="symbols">
                  <t>
                    <spanx style="verb">equals</spanx>: the two values must be identical strings.
                  </t>
                  <t>
                    <spanx style="verb">contains</spanx>: the entire <spanx style="verb">filterValue</spanx>
                    must be a substring of the Contact field value.
                  </t>
                  <t>
                    <spanx style="verb">startswith</spanx>: the entire <spanx style="verb">filterValue</spanx>
                    must be a substring of the Contact field value, starting at the beginning of the field value. This criterion is satisfied if the two strings are equal.
                  </t>
                  <t>
                    <spanx style="verb">present</spanx>: a Contact matches the criterion if the field specified by
                    <spanx style="verb">filterBy</spanx> has a non-empty value, or if it contains a non empty node for complex fields.
                  </t>
                </list>
              </t>
              <t hangText="filterValue:">
                Specified the value to filter by, using the comparison method defined by <spanx style="verb">filterOp</spanx>.
              </t>
            </list>
          </t>
          <t>
            In addition, requests can filter content based on their update timestamp:
            
            <list style="hanging">
              <t hangText="updatedSince:">
                Returns only contacts that have been modified on or after the given time, specified as an xs:dateTime. The filter is based on the value of the <spanx style="verb">updated</spanx> field, and can be used independently of other filters or combined. It enables a basic syndication pattern when accessing the same data over time. The first API call returns all data, which can be stored locally. Subsequent API calls can specify <spanx style="verb">updatedSince</spanx> with the time of the last API call, so that only contacts that have been added or modified since the last API call will be returned.
              </t>
            </list>
          </t>
          <t>
            Here are a few illustrative examples of filtering matches with <spanx style="verb">filterBy</spanx>,
            <spanx style="verb">filterOp</spanx>, and <spanx style="verb">filterValue</spanx>. In each case, assume the following two contacts would be returned if no filtering parameters were provided:
            
          <figure>
            <artwork>
      {
        "id": "1",
        "name": "Chris Messina",
        "url": [
          { "value": "http://factoryjoe.com/blog", "type": "blog" }
        ]
      },
      {
        "id": "2",
        "name": "Joseph Smarr",
        "email": [
          { "value": "joseph@plaxo.com", "type": "work", "primary": "true" },
          { "value": "jsmarr@gmail.com", "type": "home" }
        ],
      }
            </artwork>
          </figure>

            Given the parameters <spanx style="verb">filterBy=name&amp;filterOp=startswith&amp;filterValue=Chr</spanx>, only the first contact (with id=1) would match and be returned. However, with parameters <spanx style="verb">filterBy=name&amp;filterOp=present</spanx>, both contacts would be returned. Given the parameters <spanx style="verb">filterBy=email&amp;filterOp=contains&amp;filterValue=plaxo.com</spanx>, only the second contact (with id=2) would match, as would it be the only contact to match given the parameters <spanx style="verb">filterBy=email&amp;filterOp=present</spanx>.
          </t>

        </section>

        <section title="Sorting">
          <t>
            Sorting allows requests to specify the order in which contacts are returned.
            
            <list style="hanging">
              <t hangText="sortBy">
                Specifies the field name whose value SHALL be used to order the returned Contacts. The sort order is determine by the <spanx style="verb">sortOrder</spanx> parameter. If <spanx style="verb">sortBy</spanx> is a Singular Field, contacts are sorted according to that field's value; if it's a Plural Field, contacts are sorted by the Value (or Major Value, if it's a Plural Bundle Field) of the field marked with "primary": "true", if any, or else the first value in the list, if any, or else they are sorted last if the given contact has no data for the given field.
              </t>
              <t hangText="sortOrder">
                The order in which the <spanx style="verb">sortBy</spanx> parameter is applied. Allowed values are <spanx style="verb">ascending</spanx> and <spanx style="verb">descending</spanx>. If none specified the sort order defaults to <spanx style="verb">ascending</spanx>. Sort order is expected to be Unicode alphabetic sort order, with no specific locale implied.
              </t>
            </list>
          </t>
        </section>

        <section title="Pagination">
          <t>
            The pagination parameters can be used together to "page through" a large number of results:
            
            <list style="hanging">
              <t hangText="startIndex:">
                Specifies the offset of the first result to be returned with respect to the list of contacts that would be returned if no offset were provided. For instance, if in a given request 10 contacts would normally be provided, if <spanx style="verb">startIndex</spanx>
                is 7 and no <spanx style="verb">count</spanx> is specified, then only the last 3 contacts in that list would be returned (contacts are zero-indexed). If <spanx style="verb">startIndex</spanx> is greater than or equal to the total number of results that would be returned, no contacts are returned. Value MUST be a non-negative integer and defaults to 0 if none specified.
              </t>
              <t hangText="count:">
                If non-zero, specifies the maximum number of contacts the service provider will return. Value MUST be a non-negative integer and defaults to 0 if none is specified. Specifying a <spanx style="verb">count</spanx> of 0 means that no limit should be placed on the number of contacts returned. Otherwise, at most <spanx style="verb">count</spanx>
                contacts will be returned, starting at <spanx style="verb">startIndex</spanx> and counting up from there.
              </t>
            </list>
            
            For instance, on an initial query, specifying <spanx style="verb">startIndex=0&amp;count=10</spanx>
            will return the first only the first 10 results. The total number of possible results is indicated by the totalCount field of results, so the client knows how many "pages" of results exist. A subsequent query of <spanx style="verb">startIndex=10&amp;count=10</spanx> will return the next 10 results, and so on.
          </t>
        </section>

        <section title="Presentation">
          <t>
            Presentation controls the format, makeup, and delivery mechanism for delivering the requested result set:
            
            <list style="hanging">
              <t hangText="fields:">
                If non-empty, each contact returned SHALL contain only the fields explicitly requested. Service Provider MAY return a subset of the requested fields if they are not supported. This field is used for efficiency when the client only wishes to access a subset of the fields normally returned in results. Value is a comma seperated list of top level field names (e.g. <spanx style="verb">id,name,email,photo</spanx>) and defaults to an emply list which means all available fields should be returned.
              </t>
              <t hangText="format:">
                Specifies the format in which the response data is returned. Service Providers MUST support the values <spanx style="verb">json</spanx> for JSON (http://json.org) and <spanx style="verb">xml</spanx> for XML (http://www.w3.org/XML/) and MAY support additional formats if desired. The format defaults to json if no format is specified. The data structure returned is equivalent in both formats, with the only difference is in the encoding of the data. Singlular Fields are encoded as string key/value pairs in JSON and tags with text content in XML, e.g. <spanx style="verb">"field": "value"</spanx> and <spanx style="verb">&lt;field&gt;value&lt;/field&gt;</spanx> respectively. Plural Fields and Plural Bundles are encoded as arrays in JSON and repeated tags in XML, e.g. <spanx style="verb">"field": [ "value1", "value2" ]</spanx> and <spanx style="verb">&lt;field&gt;value1&lt;/field&gt;&lt;field&lt;value2&lt;/field&gt;</spanx> respectively. Nodes with multiple sub-nodes are represented as objects in JSON and tags with sub-tags in XML, e.g. <spanx style="verb">"field": { "subfield1": "value1", "subfield2": "value2" }</spanx> and <spanx style="verb">&lt;field&gt;&lt;subfield1&gt;&lt;value1&gt;&lt;/subfield1&gt;&lt;subfield2&gt;value2&lt;/subfield2&gt;&lt;/field&gt;</spanx> respectively.
              </t>
              <t hangText="callback:">
                Only applies if format=json, if so, the output is wrapped in a call to the given callback function, for use with AJAX JSON-P callback invocation. For instance, if the result would normally be <spanx style="verb">{ "field": "value" }</spanx> and <spanx style="verb">callback=myFunc</spanx>, the output would be <spanx style="verb">myFunc({"field": "value"})</spanx>; See http://developer.yahoo.com/common/json.html#callbackparam for more information. Value is a JavaScript callback function name. Callback function names may only use upper and lowercase alphabetic characters (A-Z, a-z), numbers (0-9), the period (.), the underscore (_), and brackets ([ and ]). Brackets must be URL-encoded.
              </t>
            </list>
          </t>
        </section>

      </section>

      <section title="Response Format" anchor="response-format">
        <t>
          The structure of the response object returned from a successful request is as follows. The root element is <spanx style="verb">response</spanx>, which is shown explicitly as the root element in XML format, and is the anonymous root object returned when the format is json (i.e. in JSON, the response returned is the object value of the response node). The <spanx style="verb">response</spanx> node MUST contain the following child nodes, and MAY contain additional nodes that the Service Provider wishes to add to expose additional data. Note that <spanx style="verb">startIndex</spanx>, <spanx style="verb">itemsPerPage</spanx>, and <spanx style="verb">totalCount</spanx> are based on <xref target="OpenSearch" />. See the appendix for a full example.
          <list style="symbols">
            <t>
              <spanx style="verb">status</spanx>: an object indicating the success or failure of the given request, along with the version of PortableContacts supported by the Service Provider. This node MUST contain the following child nodes:             
              <list style="symbols">
                <t>
                  <spanx style="verb">code</spanx>: the numeric response code, based on HTTP response codes, as specified in <xref target="error-codes" />.
                </t>
                <t>
                  <spanx style="verb">reason</spanx>: a human-readable explanation for the response code. This is intended to provide additional information to developers, and MAY be unsuitable for direct display to end-users. Consumers SHOULD take responsibility for showing appropriate error messages to users when the Service Provider returns an error.
                </t>
                <t>
                  <spanx style="verb">version</spanx>: for now, the Service Provider MUST always return the value <spanx style="verb">1.0</spanx> to indicate its support for Portable Contacts. Future versions of Portable Contacts MAY change this version number, and Consumers designed only for this spec SHOULD check the version before processing any results and SHOULD NOT try to process results from a Service Provider that returns a version other than 1.0.
                </t>                
              </list>
            </t>
            <t>
              <spanx style="verb">startIndex</spanx>: the index of the first result returned in thi response, relative to the starting index of all results that would be returned if no <spanx style="verb">startIndex</spanx> had been requested. In general, this will be equal to the value requested by the <spanx style="verb">startIndex</spanx>, or 0 if no specific <spanx style="verb">startIndex</spanx> was requested.
            </t>
            <t>
              <spanx style="verb">itemsPerPage</spanx>: the number of results returned per page in this response. In general, this will be equal to the <spanx style="verb">count</spanx> Query Parameter, but MAY be less if the Service Provider is unwilling to return as many results per page as requested, or if there are less than the requested number of results left to return when starting at the current <spanx style="verb">startIndex</spanx>.
            </t>
            <t>
              <spanx style="verb">totalResults</spanx>: the total number of contacts that would be returned if there were no <spanx style="verb">startIndex</spanx> or <spanx style="verb">count</spanx> specified. This value tells the Consumer how many total results to expect, regardless of the current pagination being used, but taking into account the current filtering options in the request.
            </t>
            <t>
              <spanx style="verb">totalResults</spanx>: the total number of contacts that would be returned if there were no <spanx style="verb">startIndex</spanx> or <spanx style="verb">count</spanx> specified. This value tells the Consumer how many total results to expect, regardless of the current pagination being used, but taking into account the current filtering options in the request.
            </t>
            <t>
              <spanx style="verb">entry</spanx>: an array of Contact objects, one for each contact matching the request. For consistency of parsing, this value MUST always be an array of results, even if there happens to be 0 or 1 matching result.
            </t>            
          </list>
        </t>
      </section>

      <section title="Error Codes" anchor="error-codes">
        <t>
          The Service Provider MUST return a response code with every response. Response codes are numeric and based on existing HTTP response codes, as defined below. In addition to the response code, Service Providers SHOULD also provide a human-readable reason that explains the reason for the response code. This message SHOULD be intelligible to developers, but MAY be unsuitable for display to end-users. Clients SHOULD provide their own appropriate error message to users when encountering an error response.
        </t>
        <t>
          Service Providers SHOULD send their response code and message via the HTTP response code. Since it is recognized that developers do not always have an easy ability to manipulate HTTP headers, and since headers do not show up in the response body (e.g. when viewing results in a web browser), the response data also contains the code and reason fields inside the response where the response code and reason MUST be specified, unless the error is such that the Service Provider is unable to return any response data. If the Service Provider returns an HTTP status code other than 200, Consumers MUST treat it as the definitive response code, even if the response.code in the body differs (which it shouldn't). However, if the HTTP response code is 200, Consumers MUST defer to the response.code in the body as the definitive response code.
        </t>
        <t>
          Service Providers SHOULD conform the following response codes to indicate the following situations. Service Providers MAY return additional codes to indicate additional information, but are encouraged to use these codes and augment them inside the reason rather than with a separate code.
        </t>
        <t>
          <list style="hanging">
            <t hangText="200:">
              OK (response returned successfully)
            </t>
            <t hangText="400:">
              Bad Request (request was malformed or illegal and cannot be completed)
            </t>
            <t hangText="401:">
              Unauthorized (authentication headers / parameters were invalid or missing)
            </t>
            <t hangText="404:">
              Not Found (the request points to an object that does not exist, e.g. to an unknown contact uid; note that Service Providers MUST return a 200 with an empty array of contacts if the request has filtering parameters that are valid but have no matches)
            </t>
            <t hangText="500:">
              Internal Server Error (un unexpected error occurred during processing)
            </t>
            <t hangText="503:">
              Service Unavailable (service is temporarily unavailable; this may be because the Consumer has exceeded their rate-limit of requests)
            </t>
          </list>
        </t>
      </section>

    </section>

    <section title="Contact Schema">
      <t>
        The Contact schema defines the containers and attributes used to deliver an individual Contact or a list of Contacts as requested by the Consumer. The traditional contact info fields were taken directly from the vCard spec where possible <xref target="RFC2425" />, though instances of vCard's archaic spellings were modernized (e.g. <spanx style="verb">address</spanx> instead of <spanx style="verb">adr</spanx>). Even with the spelling updates, the field mappings remain equivalent, which means it should be easy to convert Portable Contacts data to and from vCard.
      </t>
      <t>
        Each contact returned MUST include the <spanx style="verb">id</spanx> and <spanx style="verb">name</spanx> fields with non-empty values, but all other fields are optional, and it is recognized that not all Service Providers will be able to provide data for all the supported fields. The field list is below is broad so that, for Service Providers that do support any of these fields, there is a standard field name available.
      </t>

      <section title="Structure">
        <t>
          Each field is defined as either a Signular Field, in which case there can be at most one instance of that field per contact, or as a Plural Field, which case any number of instances of that field may be present per contact. 
        </t>
        <t>
          Contact information is formatted using labeled attributes with either structured or unstructured string data. Each attributes has a defined occurrence count and use one of the following types:

          <list style="hanging">
            <t hangText="Simple:">
              A single string attribute which MAY specify a REQUIRED data format or allow any string. A simple field MAY contain Canonical Values specified, in which case Service Providers SHOULD try to conform to those values if appropriate, but MAY provide alternate string values to represent additional values.
            </t>
            <t hangText="Boolean">
              An attribute with one of two allowed values: <spanx style="verb">true</spanx> and
              <spanx style="verb">false</spanx>. Values are case-sensitive.
            </t>
            <t hangText="Complex:">
              A multi-value attribute containing any combination of other attributes. Complex attributes are defined by listing the child attributes and their types. For most Complex Fields, the <spanx style="verb">value</spanx> sub-field contains the Major Value of that field (i.e. the primary piece of contact information described by that field), and the other fields provide additional meta-data.
            </t>
          </list>
        </t>
      </section>

      <section title="entry Element">
        <t>
          Unless otherwise specified, all fields are optional and of type xs:string. Also, unless specified, all field values MUST NOT contain any newline characters (\r or \n).
        </t>
        <section title="Singular Fields">
          <t>
            <list style="hanging">
              <t hangText="id:">
                Unique identifier for the Contact. Each Contact returned MUST include a non-empty id value. This identifier MUST be unqiue across this user's entire set of Contacts, but MAY not be unique across multiple users' data. It MUST be a stable ID that does not change when the same contact is returned in subsequent requests. For instance, an e-mail address is not a good id, because the same person may get a different e-mail address in the future. Usually, in internal databsase ID will be the right choice here, e.g. <spanx style="verb">"12345"</spanx>.
              </t>
              <t hangText="name:">

                The name of this Contact, suitable for display to end-users. Each Contact returned MUST include a non-empty name value. The name SHOULD be the full-name of the Contact being described if known (e.g. <spanx style="verb">Joseph Smarr</spanx> or <spanx style="verb">Mr. Joseph Robert Smarr, Esq.</spanx>), but MAY be a username or handle, if that is all that is available (e.g. <spanx style="verb">jsmarr</spanx>). The value provided SHOULD be the primary textual label by which this Contact is normally displayed by the Service Provider when presenting it to end-users.

              </t>
              <t hangText="familyName:">
                The family name of this Contact, or "Last Name" in most Western languages (e.g. <spanx style="verb">Smarr</spanx> given the full name <spanx style="verb">Mr. Joseph Robert Smarr, Esq.</spanx>).
              </t>
              <t hangText="givenName:">
                The given name of this Contact, or "First Name" in most Western languages (e.g. <spanx style="verb">Joseph</spanx> given the full name <spanx style="verb">Mr. Joseph Robert Smarr, Esq.</spanx>).
              </t>
              <t hangText="middleName:">
                The middle name(s) of this Contact (e.g. <spanx style="verb">Robert</spanx> given the full name <spanx style="verb">Mr. Joseph Robert Smarr, Esq.</spanx>).
              </t>
              <t hangText="honorificPrefix:">
                The honorific prefix(es) of this Contact, or "Title" in most Western languages (e.g. <spanx style="verb">Mr.</spanx> given the full name <spanx style="verb">Mr. Joseph Robert Smarr, Esq.</spanx>).
              </t>
              <t hangText="honorificSuffix:">
                The honorifix suffix(es) of this Contact, or "Suffix" in most Western languages (e.g. <spanx style="verb">Esq.</spanx> given the full name <spanx style="verb">Mr. Joseph Robert Smarr, Esq.</spanx>).
              </t>
              <t hangText="nickname:">
                The casual way to address this Contact in real life, e.g. "Bob" or "Bobby" instead of "Robert". This field SHOULD NOT be used to represent a user's username (e.g. <spanx style="verb">jsmarr</spanx> or <spanx style="verb">daveman692</spanx>); the latter should be represented by the <spanx style="verb">preferredUsername</spanx> field.
              </t>
              <t hangText="published:">
                The date this Contact was first added to the user's address book or friends list (i.e. the creation date of this entry). The value MUST be a valid xd:dateTime (e.g. <spanx style="verb">2008-01-23T04:56:22Z</spanx>).
              </t>
              <t hangText="updated:">
                The most recent date the details of this Contact were updated (i.e. the modified date of this entry). The value MUST be a valid xd:dateTime (e.g. <spanx style="verb">2008-01-23T04:56:22Z</spanx>). If this Contact has never been modified since its initial creation, the value MUST be the same as the value of <spanx style="verb">published</spanx>. Note the <spanx style="verb">updatedSince</spanx> Query Parameter described in <xref target="query-params" /> can be used to select only contacts whose <spanx style="verb">updated</spanx> value is equal to or more recent than a given xs:dateTime. This enables Consumers to repeatedly access a user's data and only request newly added or updated contacts since the last access time.
              </t>
              <t hangText="birthday:">
                The birthday of this contact. The value MUST be a valid xs:date (e.g. <spanx style="verb">1975-02-14</spanx>. The year value MAY be set to <spanx style="verb">0000</spanx> when the age of the Contact is private or the year is not available.
              </t>
              <t hangText="anniversary:">
                The wedding anniversary of this contact. The value MUST be a valid xs:date (e.g. <spanx style="verb">1975-02-14</spanx>. The year value MAY be set to <spanx style="verb">0000</spanx> when the year is not available.
              </t>
              <t hangText="gender:">
                The gender of this contact. Service Providers SHOULD return one of the following Canonical Values, if appropriate: <spanx style="verb">male</spanx>, <spanx style="verb">female</spanx>, and <spanx style="verb">undisclosed</spanx>, and MAY return a different value if it is not covered by one of these Canonical Values.
              </t>
              <t hangText="note:">
                Notes about this contact, with an unspecified meaning or usage (normally contact notes by the user about this contact). This field MAY contain newlines.
              </t>
              <t hangText="preferredUsername:">
                The preferred username of this contact on sites that ask for a username (e.g. <spanx style="verb">jsmarr</spanx>). This field may be more useful for describing the owner (i.e. the value when /@me/@self is requested) than the user's contacts, e.g. Consumers MAY wish to use this value to pre-populate a username for this user when signing up for a new service.
              </t>
              <t hangText="utcOffset:">
                The offset from UTC of this Contact's current eime zone, as of the the time this response was returned. The value MUST conform to the offset portion of xs:dateTime, e.g. <spanx style="verb">-08:00</spanx>. Note that this value MAY change over time due to daylight saving time, and is thus meant to signify only the current value of the user's timezone offset. 
              </t>            
              <t hangText="connected:">
                Boolean value indicating whether the user and this Contact have established a bi-directionally asserted connection of some kind on the Service Provider's service. The value MUST be either <spanx style="verb">true</spanx> or <spanx style="verb">false</spanx>. The value MUST be true if and only if there is at least one value for the <spanx style="verb">relationship</spanx> field, described below, and is thus intended as a summary value indicating that some type of bi-directional relationship exists, for Consumers that aren't interested in the specific nature of that relationship. For traditional address books, in which a user stores information about other contacts without their explicit acknowledgment, or for services in which users choose to "follow" other users without requiring mutual consent, this value will always be false.
              </t>
            </list>
            The following additional Singular Fields are defined, based on their specification in OpenSocial:
            <spanx style="verb">aboutMe</spanx>,
            <spanx style="verb">bodyType</spanx>,
            <spanx style="verb">currentLocation</spanx>,
            <spanx style="verb">drinker</spanx>,
            <spanx style="verb">ethnicity</spanx>,
            <spanx style="verb">fashion</spanx>,
            <spanx style="verb">happiestWhen</spanx>,
            <spanx style="verb">humor</spanx>,
            <spanx style="verb">livingArrangement</spanx>,
            <spanx style="verb">lookingFor</spanx>,
            <spanx style="verb">profileSong</spanx>,
            <spanx style="verb">profileVideo</spanx>,
            <spanx style="verb">relationshipStatus</spanx>,
            <spanx style="verb">religion</spanx>,
            <spanx style="verb">romance</spanx>,
            <spanx style="verb">scaredOf</spanx>,
            <spanx style="verb">sexualOrientation</spanx>,
            <spanx style="verb">smoker</spanx>, and
            <spanx style="verb">status</spanx>.
          </t>
        </section>
        <section title="Plural Fields">      
          <t>
            Unless specified otherwise, all Plural Fields have the same three standard sub-fields:
            <list style="hanging">
              <t hangText="value:">
                The primary value of this field, e.g. the actual e-mail address, phone number, or URL. When specifing a <spanx style="verb">sortBy</spanx> field in the Query Parameters for a Plural Field, the default meaning is to sort based on this <spanx style="verb">value</spanx> sub-field. Each non-empty Plural Field value MUST contain at least the value sub-field, but all other sub-fields are optional.
              </t>
              <t hangText="type:">
                The type of field for this instance, usually used to label the preferred function of the given contact information. Unless otherwise specified, this string value specifies Canonical Values of <spanx style="verb">work</spanx>, <spanx style="verb">home</spanx>, and <spanx style="verb">other</spanx>. As with all such Enumeration Fields, Service Providers SHOULD conform to one of the Canonical Values if appropriate, but MAY use an alternate value if they choose.
              </t>
              <t hangText="primary:">
                A Boolean value indicating whether this instance of the Plural Field is the primary or preferred value of for this field, e.g. the preferred mailing address or primary e-mail address. Service Providers MUST NOT mark more than one instance of the same Plural Field as primary="true", and MAY choose not to mark any fields as primary, if this information is not available. For efficiency, Service Providers SHOULD NOT mark all non-primary fields with primary="false".
              </t>
            </list>
            When returning Plural Fields, Service Providers SHOULD canonicalize the value returned, if appropriate (e.g. for e-mail addresses and URLs). Providers MAY return the same value more than once with different types (e.g. the same e-mail address may used for work and home), but SHOULD NOT return the same (type, value) combination more than once per Plural Field, as this complicates processing by the Consumer.

            <list style="hanging">
              <t hangText="email:">
                E-mail address for this Contact. The value SHOULD be canonicalized by the Service Provider, e.g. <spanx style="verb">joseph@plaxo.com</spanx> instead of <spanx style="verb">joseph@PLAXO.COM</spanx>.
              </t>
              <t hangText="url:">
                URL of a web page relating to this Contact. The value SHOULD be canonicalized by the Service Provider, e.g. <spanx style="verb">http://josephsmarr.com/about/</spanx> instead of <spanx style="verb">JOSEPHSMARR.COM/about/</spanx>. In addition to the standard Canonical Values for type, this field also defines the additional Canonical Values <spanx style="verb">blog</spanx> and <spanx style="verb">profile</spanx>.
              </t>
              <t hangText="phoneNumber:">
                Phone number for this Contact. No canonical value is assumed here. In addition to the standard Canonical Values for this type, this field also defines the additional Canonical Values <spanx style="verb">mobile</spanx>, <spanx style="verb">fax</spanx>, and <spanx style="verb">pager</spanx>.
              </t>
              <t hangText="im:">
                Instant messaging address for this Contact. No official canonicalization rules exist for all instant messsging addresses, but Service Providers SHOULD remove all whitespace and convert the address to lowercase, if this is appropriate for the service this IM address is used for. Instead of the standard Canonical Values for type, this field defines the following Canonical Values to represent currently popular IM services: <spanx style="verb">aim</spanx>, <spanx style="verb">gtalk</spanx>, <spanx style="verb">icq</spanx>, <spanx style="verb">xmpp</spanx>, <spanx style="verb">msn</spanx>, <spanx style="verb">skype</spanx>, <spanx style="verb">qq</spanx>, and <spanx style="verb">yahoo</spanx>.
              </t>

              <t hangText="photo:">
                URL of a photo of this contact. The value SHOULD be a canonicalized URL, and MUST point to an actual image file (e.g. a GIF, JPEG, or PNG image file) rather than to a web page containing an image. Service Providers MAY return the same image at different sizes, though it is recognized that no standard for describing images of various sizes currently exists. Note that this field SHOULD NOT be used to send down arbitrary photos taken by this user, but specifically profile photos of the contact suitable for display when describing the contact.
              </t>
              <t hangText="tag:">
                A user-defined category label for this contact, e.g. "favorite" or "web20".
              </t>
              <t hangText="relationship:">
                A bi-directionally asserted relationship type that was established between the user and this contact by the Service Provider. The value SHOULD conform to one of the XFN relationship values (e.g. kin, friend, contact, etc.) if appropriate, but MAY be an alternative value if needed. Note this field is a parallel set of category labels to the <spanx style="verb">tag</spanx> field, but relationships MUST have been bi-directionally confirmed, whereas tags are asserted by the user without acknoledgment by this Contact.
              </t>
              <t hangText="address:">
                A physical mailing address for this Contact, as described in <xref target="address_element" />.
              </t>
              <t hangText="job:">
                A current or past organizational affiliation of this Contact, as described in <xref target="job_element" />.
              </t>
              <t hangText="account:">
                An online account held by this Contact, as described in <xref target="account_element" />.
              </t>
            </list>
            The following additional Plural Fields are defined, based on their specification in OpenSocial:
            <spanx style="verb">activities</spanx>,
            <spanx style="verb">books</spanx>,
            <spanx style="verb">cars</spanx>,
            <spanx style="verb">children</spanx>,
            <spanx style="verb">food</spanx>,
            <spanx style="verb">heroes</spanx>,
            <spanx style="verb">interests</spanx>,
            <spanx style="verb">jobInterests</spanx>,
            <spanx style="verb">languages</spanx>,
            <spanx style="verb">languagesSpoken</spanx>,
            <spanx style="verb">movies</spanx>,
            <spanx style="verb">music</spanx>,
            <spanx style="verb">pets</spanx>,
            <spanx style="verb">politicalViews</spanx>,
            <spanx style="verb">quotes</spanx>,
            <spanx style="verb">sports</spanx>,
            <spanx style="verb">turnOffs</spanx>,
            <spanx style="verb">turnOns</spanx>, and
            <spanx style="verb">tvShows</spanx>.
          </t>
        </section>
      </section>

      <section title="address Element" anchor="address_element">
        <t>
          The components of a physical mailing address. Service Providers MAY return just the full address as a single string in the <spanx style="verb">formatted</spanx> sub-field, or they MAY return just the individual component fields using the other sub-fields, or the MAY return both. If both variants are returned, they SHOULD be describing the same address, with the formatted address indicating how the component fields should be combined.
          <list style="hanging">
            <t hangText="formatted:">
              The full mailing address, formatted for display or use with a mailing label. This field MAY contain newlines.
            </t>
            <t hangText="streetAddress:">
              The full street address component, which may include house number, street name, PO BOX, and multi-line extended street address information. This field MAY contain newlines.
            </t>
            <t hangText="locality:">
              The city or locality component.
            </t>
            <t hangText="region:">
              The state or region component.
            </t>
            <t hangText="postalCode:">
              The zipcode or postal code component.
            </t>
            <t hangText="country:">
              The country name component.
            </t>
          </list>
        </t>
      </section>

      <section title="job Element" anchor="job_element">
        <t>
          Describes a current or past organizational affiliation of this contact. Service Providers that support only a single Company Name and Job Title field should represent them with a single job element with name and title properties, respectively. 
          <list style="hanging">
            <t hangText="name:">
              The name of the organization (e.g. company, school, or other organization). This field MUST have a non-empty value for each job returned.
            </t>
            <t hangText="department:">
              The department within this organization.
            </t>
            <t hangText="title:">
              The job title or organizational role within this organization.
            </t>
            <t hangText="startDate:">
              The date this Contact joined this organization. This value SHOULD be a valid xs:date if possible, but MAY be an unformatted string, since it is recognized that this field is often presented as free-text.
            </t>
            <t hangText="endDate:">
              The date this Contact left this organization or the role specified by title within this organization. This value SHOULD be a valid xs:date if possible, but MAY be an unformatted string, since it is recognized that this field is often presented as free-text.
            </t>
            <t hangText="location:">
              The physical location of this organization. This may be a complete address, or an abbreviated location like "San Francisco".
            </t>
            <t hangText="description:">
              A textual description of the role this Contact played in this organization. This field MAY contain newlines.
            </t>
          </list>
        </t>
      </section>

      <section title="account Element" anchor="account_element">
        <t>
          Describes an account held by this Contact, which MAY be on the Service Provider's service, or MAY be on a different service. Consumers SHOULD NOT assume that this account has been verified by the Service Provider to actually belong to this Contact. For each account, the <spanx style="verb">domain</spanx> is the top-most authoritative domain for this account, e.g. <spanx style="verb">yahoo.com</spanx> or <spanx style="verb">reader.google.com</spanx>, and MUST be non-empty. Each account must also contain a non-empty value for either <spanx style="verb">userName</spanx> or<spanx style="verb">userId</spanx>, and MAY contain both, in which case the two values MUST be for the same account. These accounts can be used to determine if a user on one service is also known to be the same person on a different service, to facilitate connecting to people the user already knows on different services. If Consumers want to turn these accounts into profile URLs, they can use an open-source library like <xref target="google-sgnodemapper" />.
          <list style="hanging">
            <t hangText="domain:">
              The top-most authoritative domain for this account, e.g. "twitter.com".
            </t>
            <t hangText="userName:">
              An alphanumeric user name, usually chosen by the user, e.g. "jsmarr".
            </t>
            <t hangText="userId:">
              A user ID number, usually chosen automatically, and usually numeric but sometimes alphanumeric, e.g. "12345" or "1Z425A".
            </t>
          </list>
        </t>
      </section>

    </section>

    <appendix title="Example">
      <t>
        Here is a sample request and response that illustrates much of Portable Contacts. For simplicity, authorization information is not shown in the request.
      </t>
      <t>Sample request (via HTTP GET):</t>
      <t>
        <figure>
          <artwork>
http://sample.site.org/path/to/api/@me/@all?startIndex=10&count=10&sortBy=name
          </artwork>
        </figure>
      </t>
      <t>Sample response:</t>
      <t>
        <figure>
          <artwork>
{
  "status": {
    "code": 200,
    "reason": "OK",
    "version": "1.0",
  },
  "totalResults": 12,
  "startIndex": 10
  "itemsPerPage": 10
  "entry": [
    {
      "id": "123,"
      "name": "Minimal Contact"
    }
    {
      "id": "703887", 
      "name": "Mark Hashimoto",
      "familyName": "Hashimoto", 
      "givenName": "Mark", 
      "birthday": "0000-01-16",       
      "gender": "male",
      "drinker": "heavily",
      "tags": [
        "plaxo guy"
      ],
      "email": [
        {
          "value": "mhashimoto-04@plaxo.com", 
          "type": "work",
          "primary": "true",
        }, 
        {
          "value": "mhashimoto-04@plaxo.com", 
          "type": "home"
        }, 
        {
          "value": "mhashimoto@plaxo.com", 
          "type": "home"
        }
      ], 
      "url": [
        {
          "value": "http://www.seeyellow.com", 
          "type": "work"
        }, 
        {
          "value": "http://www.angryalien.com", 
          "type": "home"
        }
      ], 
      "phoneNumber": [
        {
          "value": "KLONDIKE5", 
          "type": "work"
        },
        {
          "value": "650-123-4567",
          "type": "mobile"
        }
      ], 
      "photo": [
        {
          "value": "http://sdev04.plaxo.com/fetch_image?path=2706_1_-78265666", 
          "type": "thumbnail"
        }
      ], 
      "im": [
        {
          "value": "plaxodev8", 
          "type": "aim"
        }
      ], 
      "address": [
        {
          "type": "home", 
          "streetAddress": "742 Evergreen Terrace\nSuite 123", 
          "locality": "Springfield", 
          "region": "VT",
          "postalCode": "12345",
          "country": "USA",
          "formatted": 742 Evergreen Terrace\nSuite 123\nSpringfield, VT 12345 USA"
        }
      ], 
      "job": [
        {
          "name": "Burns Worldwide", 
          "title": "Head Bee Guy"
        }
      ], 
      "account": [
        {
          "domain": "plaxo.com", 
          "userId": "2706"
        }
      ]
    }
  ]
}          
          </artwork>
        </figure>
      </t>
    </appendix>

    <appendix title="Security and Privacy Considerations">
      <t>
        TODO: What should we put here? Don't share private info with people that shouldn't normally have access to it? Remember what each user sees about a given contact may differ? Don't share auth creds?
      </t>
    </appendix>

  </middle>

  <back>

    <references title="References">

      <reference anchor="OAuth Core 1.0">
        <front>
          <title>OAuth Core 1.0</title>
          <author initials="" surname="OAuth Core Workgroup" fullname="OAuth Core Workgroup">
            <organization />
          </author>
        </front>
        <format type="HTML" target="http://oauth.net/core/1.0" />
      </reference>

      <reference anchor="OAuth Discovery">
        <front>
          <title>OAuth Discovery 1.0</title>
          <author initials="E.H.-L." surname="Eran Hammer-Lahav" fullname="Eran Hammer-Lahav">
            <organization />
          </author>
        </front>
        <format type="HTML" target="http://oauth.net/discovery/ " />
      </reference>      

      <reference anchor="XRDS-Simple">
        <front>
          <title>XRDS-Simple 1.0</title>
          <author initials="E.H.-L." surname="Hammer-Lahav" fullname="Eran Hammer-Lahav">
            <organization />
          </author>
        </front>
        <format type="HTML" target="http://xrds-simple.net/core/1.0/" />
      </reference>

      <reference anchor="OpenSearch">
        <front>
          <title>OpenSearch 1.1</title>
          <author initials="D.C." surname="Clinton" fullname="DeWitt Clinton">
            <organization>A9</organization>
          </author>
        </front>
        <format type="HTML" target="http://www.opensearch.org/Specifications/OpenSearch/1.1/Draft_3" />
      </reference>

      <reference anchor="RFC2606">
        <front>
          <title>Reserved Top Level DNS Names</title>
          <author initials="D.E" surname="Eastlake" fullname="D. Eastlake">
            <organization></organization>
          </author>
          <author initials="A.P" surname="Panitz" fullname="A. Panitz">
            <organization></organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="2606" />
      </reference>

      <reference anchor="RFC2119">
        <front>
          <title>Key words for use in RFCs to Indicate Requirement Levels</title>
          <author initials="B.S" surname="Bradner" fullname="Scott Bradner">
            <organization>Alis Technologies</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="2119" />
      </reference>
      
      <reference anchor="RFC2617">
        <front>
          <title>HTTP Authentication: Basic and Digest Access Authentication</title>
          <author initials="J.F." surname="Franks" fullname="J. Franks">
            <organization />
          </author>
        </front>
        <seriesInfo name="RFC" value="2617" />
      </reference>

      <reference anchor="RFC2425">
        <front>
          <title>A MIME Content-Type for Directory Information</title>
          <author initials="T.H." surname="Howes" fullname="T. Howes">
            <organization />
          </author>
        </front>
        <seriesInfo name="RFC" value="2425" />
      </reference>
      
      <reference anchor="google-sgnodemapper">
        <front>
          <title>Social Graph Node Mapper</title>
          <author initials="B.F." surname="Fitzpatrick" fullname="Brad Fitzpatrick">
            <organization />
          </author>
        </front>
        <format type="HTML" target="http://code.google.com/p/google-sgnodemapper/" />
      </reference>     
      
    </references>
  </back>

</rfc>
