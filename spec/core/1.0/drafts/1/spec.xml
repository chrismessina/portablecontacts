<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet type='text/xsl' href='http://xml.resource.org/authoring/rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<rfc category="info" ipr="full3978" docName="portable_contacts-1_0.xml">

  <?rfc toc="yes" ?>
  <?rfc tocdepth="3" ?>
  <?rfc symrefs="yes" ?>
  <?rfc sortrefs="yes"?>
  <?rfc strict="yes" ?>
  <?rfc iprnotified="no" ?>
  <?rfc private="Implementers' Draft" ?>

  <front>
    <title>Portable Contacts 1.0 Draft A</title>

    <author initials="J" surname="Smarr" fullname="Joseph Smarr">
      <organization>Plaxo</organization>
      <address>
        <email>joseph@plaxo.com</email>
      </address>
    </author>

    <date day="11" month="June" year="2008"/>

    <abstract>
      <t>
        The goal of Portable Contacts is to make it easier for developers to give their
        users a secure way to access the address books and friends lists they have built
        up all over the web. Specifically, it seeks to create a common access pattern and
        contact schema that any site can provide, a well-specified authentication and access rules,
        standard libraries that can work with any site, and absolutely minimal complexity,
        with the lightest possible toolchain requirements for developers.
      </t>
    </abstract>

  </front>
  <middle>

    <section title="Notation and Conventions">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref target="RFC2119" />.
        Domain name examples use <xref target="RFC2606" />.
      </t>
    </section>

    <section title="Definitions">
      <t>
        <list style="hanging">
          <t hangText="Contact:">
            .
          </t>
          <t hangText="Service Provider:">
            A web application that provides Contacts information
            via the Portable Contacts protocol.
          </t>
          <t hangText="Consumer:">
            A website or application that uses the Portable Contacts protocol
            to request contacts managed by the Service Provider.
          </t>
        </list>
      </t>
    </section>

    <section title="Overview">
      <t>
      </t>
    </section>

    <section title="Discovery">
      <t>
        Portable contacts API endpoint is discoverable from the domain root using XRDS-Simple (YADIS).
        Will specify new URI type for this service.
        Endpoint is base URL for API; additional path and query vars can be appended during invocation.
      </t>
    </section>

    <section title="Invocation">
      <t>
      </t>

      <section title="Authentication and Authorization">
        <t>
        </t>
      </section>

      <section title="Query Parameters">
        <t>
          Portable Contacts defines a standard set of operations that can be used
          to filter, sort, and paginate response results. The operations are specified
          by adding query parameter to the request URL, either in the query string or as
          HTTP POST data.
        </t>

        <section title="Filtering">
          <t>
            Filtering is used to limit the request results to Contacts that match a given
            criterion. Content filtering is accomplished by combining three request parameters:

            <list style="hanging">
              <t hangText="filterBy:">
                Specifies the field name to filter by. If the field is not a direct child of the
                <spanx style="verb">contact</spanx> element, the full path MUST be specified using
                the '/' character as seperator. For example, to filter by gender the paramter value
                is 'gender' and to filter by first name, the parameter value is 'name/givenName'.
              </t>
              <t hangText="filterOp:">
                Defines the comparison method used to evaluate the field value with the value of
                the filter criterion. Allowed values are:
                <list style="symbols">
                  <t>
                    <spanx style="verb">equals</spanx>: the two values must be identical strings.
                  </t>
                  <t>
                    <spanx style="verb">contains</spanx>: the entire <spanx style="verb">filterValue</spanx>
                    must be a substring of the Contact field value.
                  </t>
                  <t>
                    <spanx style="verb">startswith</spanx>: the entire <spanx style="verb">filterValue</spanx>
                    must be a substring of the Contact field value, starting at the beginning of the field value. This
                    criterion is satisfied if the two strings are equal.
                  </t>
                  <t>
                    <spanx style="verb">present</spanx>: a Contact matches the criterion if the field specified by
                    <spanx style="verb">filterBy</spanx> has a non-empty value, or if it contains a non empty node
                    for complex fields.
                  </t>
                </list>
              </t>
              <t hangText="filterValue:">
                Specified the value to filter by, using the comparison method defined by <spanx style="verb">filterOp</spanx>.
              </t>
            </list>
          </t>
          <t>
            In addition, requests can filter content based on their update timestamp:
            
            <list style="hanging">
              <t hangText="modifiedSince:">
                Returns only contacts that have been modified on or after the given time, specified
                as an xs:dateTime. The filter is based on the value of the <spanx style="verb">modified</spanx> field,
                and can be used independently of other filters or combined. It enables a basic syndication pattern when
                accessing the same data over time. The first API call returns all data, which can be stored locally.
                Subsequent API calls can specify <spanx style="verb">modifiedSince</spanx> with the time of the last
                API call, so that only contacts that have been added or modified since the last API call will be returned.
              </t>
            </list>
          </t>
          <t>
            Here are a few illustrative examples of filtering matches with <spanx style="verb">filterBy</spanx>,
            <spanx style="verb">filterOp</spanx>, and <spanx style="verb">filterValue</spanx>.
            In each case, assume the following two contacts would be returned if no filtering parameters were provided:
            
          <figure>
            <artwork>
      {
        "id": "1",
        "name": "Chris Messina",
        "url": [
          { "value": "http://factoryjoe.com/blog", "type": "blog" }
        ]
      },
      {
        "id": "2",
        "name": "Joseph Smarr",
        "email": [
          { "value": "joseph@plaxo.com", "type": "work", "primary": "true" },
          { "value": "jsmarr@gmail.com", "type": "home" }
        ],
      }
            </artwork>
          </figure>

            Given the parameters <spanx style="verb">filterBy=name&amp;filterOp=startswith&amp;filterValue=Chr</spanx>,
            only the first contact (with id=1) would match and be returned. However, with
            parameters <spanx style="verb">filterBy=name&amp;filterOp=present</spanx>, both contacts would be returned.
            Given the parameters <spanx style="verb">filterBy=email&amp;filterOp=contains&amp;filterValue=plaxo.com</spanx>,
            only the second contact (with id=2) would match, as would it be the only contact
            to match given the parameters <spanx style="verb">filterBy=email&amp;filterOp=present</spanx>.
          </t>

        </section>

        <section title="Sorting">
          <t>
            Sorting allows requests to specify the order in which contacts are returned.
            
            <list style="hanging">
              <t hangText="sortBy">
                Specifies the field name whose value SHALL be used to order the returned Contacts.
                The sort order is determine by the <spanx style="verb">sortOrder</spanx> parameter.
                If <spanx style="verb">sortBy</spanx> is a Singular Field, contacts are sorted according
                to that field’s value; if it’s a Plural Field, contacts are sorted by the Value
                (or Major Value, if it’s a Plural Bundle Field) of the field marked with “primary”: “true”,
                if any, or else the first value in the list, if any, or else they are sorted last if the
                given contact has no data for the given field.
              </t>
              <t hangText="sortOrder">
                The order in which the <spanx style="verb">sortBy</spanx> parameter is applied. Allowed values
                are <spanx style="verb">ascending</spanx> and <spanx style="verb">descending</spanx>. If none specified
                the sort order defaults to <spanx style="verb">ascending</spanx>. Sort order is expected to be
                Unicode alphabetic sort order, with no specific locale implied.
              </t>
            </list>
          </t>
        </section>

        <section title="Pagination">
          <t>
            The pagination parameters can be used together to “page through” a large number of results:
            
            <list style="hanging">
              <t hangText="startIndex:">
                Specifies the offset of the first result to be returned with respect to the list
                of contacts that would be returned if no offset were provided. For instance, if
                in a given request 10 contacts would normally be provided, if <spanx style="verb">startIndex</spanx>
                is 7 and no <spanx style="verb">limit</spanx> is specified, then only the last 3 contacts in that
                list would be returned (contacts are zero-indexed). If <spanx style="verb">startIndex</spanx> is
                greater than or equal to the total number of results that would be returned, no contacts are returned.
                Value MUST be a non-negative integer and defaults to 0 if none specified.
              </t>
              <t hangText="limit:">
                If non-zero, specifies the maximum number of contacts the service provider will return.
                Value MUST be a non-negative integer and defaults to 0 if none is specified. Specifying
                a <spanx style="verb">limit</spanx> of 0 means that no limit should be placed
                on the number of contacts returned. Otherwise, at most <spanx style="verb">limit</spanx>
                contacts will be returned, starting at <spanx style="verb">startIndex</spanx> and counting
                up from there.
              </t>
            </list>
            
            For instance, on an initial query, specifying <spanx style="verb">startIndex=0&amp;limit=10</spanx>
            will return the first only the first 10 results. The total number of possible results is indicated
            by the totalCount field of results, so the client knows how many “pages” of results exist.
            A subsequent query of <spanx style="verb">startIndex=10&amp;limit=10</spanx> will return the next
            10 results, and so on.
          </t>
        </section>

        <section title="Presentation">
          <t>
            Presentation controls the format, makeup, and delivery mechanism for delivering the requested
            result set:
            
            <list style="hanging">
              <t hangText="format:">
                Specifies the format in which the response data is returned. Supports: JSON (http://json.org)
                or XML (http://www.w3.org/XML/) and defaults to JSON is none specified.
                The data structure returned is equivalent in both formats,
                with the only difference is in the encoding of the data. Singlular Fields are encoded as string
                key/value pairs in JSON and tags with text content in XML, e.g. “field”: “value” and
                &lt;field&gt;value&lt;/field&gt; respectively. Plural Fields and Plural Bundles are encoded as
                arrays in JSON and repeated tags in XML, e.g. “field”: [ “value1”, “value2” ] and
                &lt;field&gt;value1&lt;/field&gt;&lt;field&lt;value2&lt;/field&gt; respectively.
                Nodes with multiple sub-nodes are represented as objects in JSON and tags with
                sub-tags in XML, e.g. “field”: { “subfield1”: “value1”, “subfield2”: “value2” }
                and &lt;field&gt;&lt;subfield1&gt;&lt;value1&gt;&lt;/subfield1&gt;&lt;subfield2&gt;value2&lt;/subfield2&gt;&lt;/field&gt;
                respectively.
              </t>
              <t hangText="fields:">
                If non-empty, each contact returned SHALL contain only the fields explicitly requested.
                Service Provider MAY return a subset of the requested fields if they are not supported.
                This field is used for efficiency when the client only wishes to access a subset of the
                fields normally returned in results. Value is a comma seperated list of top level field names
                and defaults to an emply list which means all fields.
              </t>
              <t hangText="callback:">
                Only applies if format=json, if so, the output is wrapped in a call to the given callback
                function, for use with AJAX JSON-P callback invocation. For instance, if the result would
                normally be { “field”: “value” } and callback=myFunc, the output would be myFunc({“field”: “value”});
                See http://developer.yahoo.com/common/json.html#callbackparam for more information. Value
                is a JavaScript callback function name. Callback function names may only use upper and
                lowercase alphabetic characters (A-Z, a-z), numbers (0-9), the period (.), the underscore (_),
                and brackets ([ and ]). Brackets must be URL-encoded.
              </t>
            </list>
          </t>
        </section>

      </section>

      <section title="Response Format">
        <t>
        </t>
      </section>

      <section title="Error Codes">
        <t>
          The Service Provider MUST return a response code with every response.
          Response codes are numeric and based on existing HTTP response codes,
          as defined below. In addition to the response code, Service Providers
          SHOULD also provide a human-readable reason that explains the reason
          for the response code. This message SHOULD be intelligible to
          developers, but MAY be unsuitable for display to end-users.
          Clients SHOULD provide their own appropriate error message to users
          when encountering an error response.
        </t>
        <t>
          Service Providers SHOULD send their response code and message via the
          HTTP response code. Since it is recognized that developers do not always
          have an easy ability to manipulate HTTP headers, and since headers do not
          show up in the response body (e.g. when viewing results in a web browser),
          the response data also contains the code and reason fields inside the
          response where the response code and reason MUST be specified, unless the
          error is such that the Service Provider is unable to return any response
          data. If the Service Provider returns an HTTP status code other than 200,
          Consumers MUST treat it as the definitive response code, even if the
          response.code in the body differs (which it shouldn’t). However, if the
          HTTP response code is 200, Consumers MUST defer to the response.code in the
          body as the definitive response code.
        </t>
        <t>
          Service Providers SHOULD conform the following response codes to indicate
          the following situations. Service Providers MAY return additional codes to
          indicate additional information, but are encouraged to use these codes and
          augment them inside the reason rather than with a separate code.
        </t>
        <t>
          <list style="hanging">
            <t hangText="200:">
              OK (response returned successfully)
            </t>
            <t hangText="400:">
              Bad Request (request was malformed or illegal and cannot be completed)
            </t>
            <t hangText="401:">
              Unauthorized (authentication headers / parameters were invalid or missing)
            </t>
            <t hangText="404:">
              Not Found (the request points to an object that does not exist, e.g. to an
              unknown contact uid; note that Service Providers MUST return a 200 with an
              empty array of contacts if the request has filtering parameters that are
              valid but have no matches)
            </t>
            <t hangText="500:">
              Internal Server Error (un unexpected error occurred during processing)
            </t>
            <t hangText="503:">
              Service Unavailable (service is temporarily unavailable; this may be
              because the Consumer has exceeded their rate-limit of requests)
            </t>
          </list>
        </t>
      </section>

    </section>

    <section title="Contact Schema">
      <t>
        The Contact schema defines the containers and attributes used to deliver
        an individual Contact or a list of Contacts as requested by the Consumer.
      </t>

      <section title="Structure">
        <t>
          Contact information is formatted using labeled attributes with either
          structured or unstructured string data. Each attributes has a defined
          occurrence count and use one of the following types:

          <list style="hanging">
            <t hangText="Simple:">
              A single string attribute which MAY specify a REQUIRED data format or allow
              any string.
            </t>
            <t hangText="Enumeration:">
              A single string attribute with a defined set of allowed values. Service Providers
              MAY extend the schema to include additional enumeration values, but SHOULD prefix
              them with a unique namespace as defined in <xref target="namespaces" />.
            </t>
            <t hangText="Boolean">
              An attribute with one of two allowed values: <spanx style="verb">true</spanx> and
              <spanx style="verb">false</spanx>. Values are case-sensitive.
            </t>
            <t hangText="Complex:">
              A multi-value attribute containing any combination of other attributes. Complex
              attributes are defined by listing the child attributes and their types.
            </t>
          </list>
        </t>
      </section>

      <section title="Namespaces" anchor="namespaces">
        <t>
        </t>
      </section>

      <section title="contact Element">
        <t>
          <list style="hanging">
            <t hangText="id:">
              1 per <spanx style="verb">contact</spanx> element with type xs:string.
              Unique identifier for the Contact.
            </t>
            <t hangText="published:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:dateTime.
            </t>
            <t hangText="updated:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:dateTime.
            </t>
            <t hangText="name:">
              1 per <spanx style="verb">contact</spanx> element with type xs:string.
              Full name or the common display name.
            </t>
            <t hangText="preferredUsername:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:string.
            </t>
            <t hangText="familyName:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:string.
            </t>
            <t hangText="givenName:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:string.
            </t>
            <t hangText="middleName:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:string.
            </t>
            <t hangText="honorificPrefix:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:string.
            </t>
            <t hangText="honorificSuffix:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:string.
            </t>
            <t hangText="bday:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:date. The
              year value MAY be set to <spanx style="verb">0000</spanx> when the age of the
              Contact is private or the year is not available.
            </t>
            <t hangText="anniversary:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:date. The
              year value MAY be set to <spanx style="verb">0000</spanx> when the year is not available.
            </t>
            <t hangText="gender:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type enumeration.
              Allowed values: <spanx style="verb">male</spanx>, <spanx style="verb">female</spanx>,
              and <spanx style="verb">undisclosed</spanx>.
            </t>
            <t hangText="note:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:string. Text notes and comments with
              multiple lines seperated by a line feed character (ASCII 13).
            </t>
            <t hangText="connected:">
              0 or 1 <spanx style="verb">contact</spanx> element with type xs:boolean. Indicates if a two-way relationship
              is established with the Contact.
            </t>
            <t hangText="email:">
              0 or more per <spanx style="verb">contact</spanx> element with REQUIRED child elements:

              <list style="hanging">
                <t hangText="type:">Enumeration: work, home, other.</t>
                <t hangText="value:">Canonical email address (put RFC here).</t>
                <t hangText="primary:">Boolean.</t>
              </list>
            </t>
            <t hangText="url:">
              0 or more per <spanx style="verb">contact</spanx> element with REQUIRED child elements:

              <list style="hanging">
                <t hangText="type:">Enumeration: work, home, other, blog, profile.</t>
                <t hangText="value:">Absolute URI with any scheme.</t>
                <t hangText="primary:">Boolean.</t>
              </list>
            </t>
            <t hangText="im:">
              0 or more per <spanx style="verb">contact</spanx> element with REQUIRED child elements:

              <list style="hanging">
                <t hangText="type:">Enumeration: aim, gtalk, icq, xmpp, msn, skype, qq, yahoo</t>
                <t hangText="value:">Screen name</t>
                <t hangText="primary:">Boolean.</t>
              </list>
            </t>
            <t hangText="phoneNumber:">
              0 or more per <spanx style="verb">contact</spanx> element with REQUIRED child elements:

              <list style="hanging">
                <t hangText="type:">Enumeration: work, home, other, mobile, fax, pager.</t>
                <t hangText="value:">String.</t>
                <t hangText="primary:">Boolean.</t>
              </list>
            </t>
            <t hangText="photo:">
              0 or more per <spanx style="verb">contact</spanx> element with REQUIRED child elements:

              <list style="hanging">
                <t hangText="type:">Enumeration: work, home, other.</t>
                <t hangText="value:">Absolute URI of the image itself (not containing pages).</t>
                <t hangText="primary:">Boolean.</t>
              </list>
            </t>
            <t hangText="tag:">
              0 or more per <spanx style="verb">contact</spanx> element with type xs:string.
              Holds a single user-defined tag.
            </t>
            <t hangText="relationship:">
              0 or more per <spanx style="verb">contact</spanx> element with type xs:string. TBD.
            </t>
            <t hangText="address:">
              0 or more per <spanx style="verb">contact</spanx> element as defined in <xref target="address_element" />.
            </t>
            <t hangText="job:">
              0 or more per <spanx style="verb">contact</spanx> element as defined in <xref target="job_element" />.
            </t>
            <t hangText="account:">
              0 or more per <spanx style="verb">contact</spanx> element as defined in <xref target="account_element" />.
            </t>
            <t hangText="utcOffset:">
              0 or 1 per <spanx style="verb">contact</spanx> element with type xs:dateTime.
            </t>
          </list>
        </t>
      </section>

      <section title="address Element" anchor="address_element">
        <t>
          <list style="hanging">
            <t hangText="streetAddress:">
              0 or more per <spanx style="verb">address</spanx> element with type xs:string.
            </t>
            <t hangText="locality:">
              0 or 1 per <spanx style="verb">address</spanx> element with type xs:string.
            </t>
            <t hangText="region:">
              0 or 1 per <spanx style="verb">address</spanx> element with type xs:string.
            </t>
            <t hangText="postalCode:">
              0 or 1 per <spanx style="verb">address</spanx> element with type xs:string.
            </t>
            <t hangText="country:">
              1 per <spanx style="verb">address</spanx> element with type xs:string.
            </t>
            <t hangText="formatted:">
              0 or more per <spanx style="verb">address</spanx> element with type xs:string.
            </t>
          </list>
        </t>
      </section>

      <section title="job Element" anchor="job_element">
        <t>
          <list style="hanging">
            <t hangText="name:">
              1 per <spanx style="verb">job</spanx> element with type xs:string.
            </t>
            <t hangText="department:">
              0 or 1 per <spanx style="verb">job</spanx> element with type xs:string.
            </t>
            <t hangText="title:">
              0 or 1 per <spanx style="verb">job</spanx> element with type xs:string.
            </t>
            <t hangText="startDate:">
              0 or 1 per <spanx style="verb">job</spanx> element with type xs:date.
            </t>
            <t hangText="endDate:">
              0 or 1 per <spanx style="verb">job</spanx> element with type xs:date.
            </t>
            <t hangText="location:">
              0 or 1 per <spanx style="verb">job</spanx> element with type xs:string.
            </t>
            <t hangText="description:">
              0 or 1 per <spanx style="verb">job</spanx> element with type xs:string.
            </t>
          </list>
        </t>
      </section>

      <section title="account Element" anchor="account_element">
        <t>
          <list style="hanging">
            <t hangText="domain:">
              1 per <spanx style="verb">account</spanx> element with type xs:string.
            </t>
            <t hangText="localId:">
              1 per <spanx style="verb">account</spanx> element with type xs:string.
            </t>
          </list>
        </t>
      </section>

    </section>

    <section title="Security and Privacy Considerations">
      <t>
      </t>
    </section>

    <appendix title="Appendix A - Example">
      <t>
      </t>
    </appendix>

  </middle>

  <back>

    <references title="References">

      <reference anchor="OAuth Core 1.0">
        <front>
          <title>OAuth Core 1.0</title>
          <author initials="" surname="OAuth Core Workgroup" fullname="OAuth Core Workgroup">
            <organization />
          </author>
        </front>
        <format type="HTML" target="http://oauth.net/core/1.0" />
      </reference>

      <reference anchor="RFC2606">
        <front>
          <title>Reserved Top Level DNS Names</title>
          <author initials="D.E" surname="Eastlake" fullname="D. Eastlake">
            <organization></organization>
          </author>
          <author initials="A.P" surname="Panitz" fullname="A. Panitz">
            <organization></organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="2606" />
      </reference>

      <reference anchor="RFC2119">
        <front>
          <title>Key words for use in RFCs to Indicate Requirement Levels</title>
          <author initials="B.S" surname="Bradner" fullname="Scott Bradner">
            <organization>Alis Technologies</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="2119" />
      </reference>

    </references>
  </back>

</rfc>
